# Dave's Dev Guidebook

Hi there. This is my attempt at writing a developer guidebook ðŸ“–. I originally did this for the STFC Hartree Centre but now I maintain an updated version here. Feel free to raise issues if you disagree with anything, its just my opinion which is subject to change - I believe that strong opinions should be loosely held. Happy reading. DaveM

Last Updated Dec 24.  Enjoy.

## Table Of Contents

```dataviewjs
dv.view('toc')
```
[//]: # (To update the manual contents table between the '--start/endContents' markers, copy the autogenerated toc within Obsidian and paste the updated text within the markers. Then select the text and use the following global line substitutions to update all the links in the toc to be GitHub compatible. To paste into command mode use 'Ctrl-R regId': 
'<,'>s/%20/-/g
'<,'>s/app:\/\/obsidian\.md\/devGuidebook\.md//g
)

--startContents
1. [Table Of Contents](#Table-Of-Contents)
2. [Why Software Dev Guidebook](#Why-Software-Dev-Guidebook)
    1. [Target Audience](#Target-Audience)
    2. [If it is not in Git it does not exist](#If-it-is-not-in-Git-it-does-not-exist)
        1. [Feature Branching vs Trunk Based development](#Feature-Branching-vs-Trunk-Based-development)
        2. [Integrating Upstream Changes](#Integrating-Upstream-Changes)
        3. [Rebase vs Merge](#Rebase-vs-Merge)
    3. [Adopt Semantic Versioning for tags and releases](#Adopt-Semantic-Versioning-for-tags-and-releases)
    4. [Review each others code and be supportive](#Review-each-others-code-and-be-supportive)
    5. [If the critical path has not been reviewed it should not go onto master branch](#If-the-critical-path-has-not-been-reviewed-it-should-not-go-onto-master-branch)
    6. [Continuous Integration - If it does not have tests it does not work](#Continuous-Integration---If-it-does-not-have-tests-it-does-not-work)
    7. [Continuous Delivery](#Continuous-Delivery)
    8. [Continuous Deployment](#Continuous-Deployment)
    9. [If it Does not have Documentation it is Not Usable](#If-it-Does-not-have-Documentation-it-is-Not-Usable)
    10. [Learning mindset](#Learning-mindset)
    11. [Customer Bill of Rights - modified from Uncle Bob Martin Clean Agile](#Customer-Bill-of-Rights---modified-from-Uncle-Bob-Martin-Clean-Agile)
    12. [Developer Bill of Rights - modified from Uncle Bob Martin Clean Agile](#Developer-Bill-of-Rights---modified-from-Uncle-Bob-Martin-Clean-Agile)
    13. [Tooling](#Tooling)
        1. [Do not be Smart - Use the Right Tools for the Job and for your customer](#Do-not-be-Smart---Use-the-Right-Tools-for-the-Job-and-for-your-customer)
        2. [To Garbage Collect or Not To GC](#To-Garbage-Collect-or-Not-To-GC)
        3. [Kanban - Jira and Confluence](#Kanban---Jira-and-Confluence)
        4. [Gitlab and Version Control](#Gitlab-and-Version-Control)
        5. [Container Repository](#Container-Repository)
        6. [Build Tools](#Build-Tools)
        7. [Static Code Analysis](#Static-Code-Analysis)
        8. [Containerisation for Portability](#Containerisation-for-Portability)
        9. [Workflows and Containerisation](#Workflows-and-Containerisation)
3. [Coding Recommendations and Best Practices](#Coding-Recommendations-and-Best-Practices)
    1. [High quality code is easy to change](#High-quality-code-is-easy-to-change)
    2. [Quality is the best shortcut - Fowler Design Stamina Hypothesis](#Quality-is-the-best-shortcut---Fowler-Design-Stamina-Hypothesis)
    3. [Do Not Name Abstractions After Constituent Parts](#Do-Not-Name-Abstractions-After-Constituent-Parts)
    4. [Naming with Meaningful and Descriptive Names](#Naming-with-Meaningful-and-Descriptive-Names)
    5. [Testing has Three Main Purposes](#Testing-has-Three-Main-Purposes)
    6. [Keep Classes and Functions Smallish](#Keep-Classes-and-Functions-Smallish)
    7. [Limit the Number of Function Arguments](#Limit-the-Number-of-Function-Arguments)
    8. [Functions should do one thing and do it well](#Functions-should-do-one-thing-and-do-it-well)
    9. [Classes and Code Should be Cohesive](#Classes-and-Code-Should-be-Cohesive)
    10. [Classes should have only one reason to change and do one thing and do it well](#Classes-should-have-only-one-reason-to-change-and-do-one-thing-and-do-it-well)
    11. [OOP Redefined](#OOP-Redefined)
    12. [SOLID](#SOLID)
    13. [Polymorphism Redefined](#Polymorphism-Redefined)
        1. [Inheritance should be explicitly designed-for](#Inheritance-should-be-explicitly-designed-for)
        2. [Avoid Paying too much Inheritance Tax - Use Parametric Polymorphism to Augment your Type-System](#Avoid-Paying-too-much-Inheritance-Tax---Use-Parametric-Polymorphism-to-Augment-your-Type-System)
        3. [Parametric Polymorphism Attaches Behaviour To Custom and Existing Types](#Parametric-Polymorphism-Attaches-Behaviour-To-Custom-and-Existing-Types)
        4. [Extension Functions for Augmenting Existing Types](#Extension-Functions-for-Augmenting-Existing-Types)
        5. [Structural Polymorphism and Duck Typing](#Structural-Polymorphism-and-Duck-Typing)
    14. [Sealing](#Sealing)
    15. [Composition / Delegation](#Composition-/-Delegation)
    16. [Data Orientated Programming vs OOP - Choose Two](#Data-Orientated-Programming-vs-OOP---Choose-Two)
    17. [Functional vs OOP - Choose Two](#Functional-vs-OOP---Choose-Two)
    18. [Dependency Inversion Principle](#Dependency-Inversion-Principle)
    19. [Dependency Injection and Inversion of Control for Decreasing Code Coupling - IoC](#Dependency-Injection-and-Inversion-of-Control-for-Decreasing-Code-Coupling---IoC)
    20. [Dynamic Late Binding vs Static Binding](#Dynamic-Late-Binding-vs-Static-Binding)
    21. [It Should Not be Possible to Create an Object in an Invalid State](#It-Should-Not-be-Possible-to-Create-an-Object-in-an-Invalid-State)
    22. [Know Some Design Patterns](#Know-Some-Design-Patterns)
        1. [The Strategy Pattern Example](#The-Strategy-Pattern-Example)
        2. [The Visitor Pattern](#The-Visitor-Pattern)
        3. [Builder Pattern for More Complex Object Creation Scenarios](#Builder-Pattern-for-More-Complex-Object-Creation-Scenarios)
    23. [Information Hiding](#Information-Hiding)
    24. [Keep it Simple Stupid KISS](#Keep-it-Simple-Stupid-KISS)
    25. [DRY Do not Repeat Yourself](#DRY-Do-not-Repeat-Yourself)
    26. [YAGNI You Are not Going to Need It](#YAGNI-You-Are-not-Going-to-Need-It)
    27. [Comment in line As You Go](#Comment-in-line-As-You-Go)
    28. [The Boy Scout Rule](#The-Boy-Scout-Rule)
    29. [Law of Demiter and Train Wrecks](#Law-of-Demiter-and-Train-Wrecks)
    30. [Do not pollute Functional Code with Mutable State](#Do-not-pollute-Functional-Code-with-Mutable-State)
    31. [Make Private your Default Class Level Visibility](#Make-Private-your-Default-Class-Level-Visibility)
    32. [Make Immutability your Default](#Make-Immutability-your-Default)
    33. [Interior Mutability](#Interior-Mutability)
    34. [Use Calculations Where Possible to Limit Side Effects](#Use-Calculations-Where-Possible-to-Limit-Side-Effects)
    35. [Separate Operations from Calculations](#Separate-Operations-from-Calculations)
    36. [Error Handling](#Error-Handling)
        1. [Error Handling - 4 Types of Problems](#Error-Handling---4-Types-of-Problems)
        2. [Error Handling - Exceptions vs Errors-as-Values](#Error-Handling---Exceptions-vs-Errors-as-Values)
        3. [Error Handling - Model Exceptions as Values with Algebraic Data Types](#Error-Handling---Model-Exceptions-as-Values-with-Algebraic-Data-Types)
        4. [Error Handling - Exceptions should not be used for flow control - exceptional does not mean conditional](#Error-Handling---Exceptions-should-not-be-used-for-flow-control---exceptional-does-not-mean-conditional)
        5. [Error Handling - Only use exceptions for exceptional situations such as coding errors and unexpected errors - exceptional does not mean conditional](#Error-Handling---Only-use-exceptions-for-exceptional-situations-such-as-coding-errors-and-unexpected-errors---exceptional-does-not-mean-conditional)
        6. [Error Handling - Provide relevant exceptions for the abstraction layer](#Error-Handling---Provide-relevant-exceptions-for-the-abstraction-layer)
        7. [Error Handling - Bubble exceptions upwards or trap at source](#Error-Handling---Bubble-exceptions-upwards-or-trap-at-source)
        8. [Error Handling â€“ Model the absence of value explicitly](#Error-Handling-%E2%80%93-Model-the-absence-of-value-explicitly)
        9. [Error Handling in Functional Programming â€“ error monads such as Either and Validated](#Error-Handling-in-Functional-Programming-%E2%80%93-error-monads-such-as-Either-and-Validated)
    37. [Data Orientated Programming with Algebraic Data Types - ADTs](#Data-Orientated-Programming-with-Algebraic-Data-Types---ADTs)
    38. [Concurrency and Parallelism](#Concurrency-and-Parallelism)
        1. [Know the difference between IO bound tasks and CPU bound tasks and their common solution patterns](#Know-the-difference-between-IO-bound-tasks-and-CPU-bound-tasks-and-their-common-solution-patterns)
    39. [Security Development Practices](#Security-Development-Practices)
4. [Agile Process Guide aka Feedback Driven Development](#Agile-Process-Guide-aka-Feedback-Driven-Development)
    1. [Design Thinking Workshops and Scoping Document](#Design-Thinking-Workshops-and-Scoping-Document)
    2. [Epics and Work Package Span Multiple Sprints](#Epics-and-Work-Package-Span-Multiple-Sprints)
    3. [Define user stories with the INVEST Framework or Who-What-Why or the Connextra Card Template â€“ all are good and you do not need to be too rigid](#Define-user-stories-with-the-INVEST-Framework-or-Who-What-Why-or-the-Connextra-Card-Template-%E2%80%93-all-are-good-and-you-do-not-need-to-be-too-rigid)
    4. [Arrange core user stories into a Journey Map with a narrative flow or backbone of Big Activities moving from left to right](#Arrange-core-user-stories-into-a-Journey-Map-with-a-narrative-flow-or-backbone-of-Big-Activities-moving-from-left-to-right)
    5. [Task Backlog](#Task-Backlog)
    6. [Requirements Document and System Architecture Document](#Requirements-Document-and-System-Architecture-Document)
    7. [1 to 2-week Sprints](#1-to-2-week-Sprints)
    8. [Inline Testing](#Inline-Testing)
    9. [Demo and Playbacks](#Demo-and-Playbacks)
    10. [Acceptance with Sign Off and Cucumbers](#Acceptance-with-Sign-Off-and-Cucumbers)
    11. [Iteration and Incrementalism](#Iteration-and-Incrementalism)
    12. [Cup Cake Road Maps](#Cup-Cake-Road-Maps)
5. [Appendix Recommended Texts](#Appendix-Recommended-Texts)
--endContents

## Why Software Dev Guidebook

To help everyone in the Centre build great software, I've put together a collection of development guidelines to help you build scalable, maintainable, reliable, performant, and usable code. Like all guidelines, these are not strict rules, and knowing when and where to apply these guidelines largely comes down to practice and experience.Â  This is not an exhaustive list. For more in-depth analysis, please see the list of recommended texts in the appendix. Not going to repeat all that good advice here, thatâ€™s what the books are for, but I have tried to distil a range of key recommendations.

> [!TIP]
> Recognise that code is navigated and read far more than it is written, and that code is a form of expression designed for humans (machine code is for the machines).


_"Programs must be written for people to read, and only incidentally for machines to execute" Harold Abelson, the author of Structure and Interpretation of Computer Programs

> [!TIP]
Good quality code should read well, with details abstracted so that higher-level code reads almost like a form of â€˜self-documentingâ€™ story which is expressive of its intent.

### Target Audience

This guide is intended for folks who read and write code. However, it is not possible to produce a â€˜one size fits allâ€™ set of guidelines for everyone.

If you predominantly use Python/R via Jupyter Notebooks for example, much of this advice might be overkill, and for that reason, there is separate section for notebooks. Recognise there are ways to bring more good software practices into Notebooks, see [https://nbdev.fast.ai/](https://nbdev.fast.ai/) which includes good stuff such as Git-friendly notebooks, built in support for CI/CD, support for tests as regular notebook cells and more.

Similarly, if youâ€™re using low-level C/C++ or Fortran, many of the guidelines might simply be unavailable to you. Please bear this in mind, these are not rules, interpret them judiciously for your scenario, and as ever, the real answer is always â€œit dependsâ€. Weâ€™ll keep evolving this document and welcome any comments.

### If it is not in Git it does not exist

- Use a GitLab/Github service - [https://gitlab.stfc.ac.uk/](https://gitlab.stfc.ac.uk/)
- Learn git concepts, not commands
- Branch early, commit little and often with â€˜logically sensible commitsâ€™ multiple times a day.
- Use a dev branch for your main development and a main branch for your production releasable code.
- Use topic branches (aka feature branches) for your new developments.

#### Feature Branching vs Trunk Based development

Research by Forsgen & Humble (â€˜Accelerateâ€™ book) shows that long-lived feature branches that remain open for prolonged periods of time hinder delivery and productivity. Team members are less likely to interact and merge conflicts are more likely. The general recommendation is to try and merge feature branches into dev every one or two days. However, the Accelerate book authors do acknowledge that longer lived feature branches are suitable for open-source development where committers are less likely to work full time on features, and so often need more long-lived feature branches.

![](attachments/Pasted%20image%2020240610204547.png)

[https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)

Tutorials: [https://github.com/davidmeredith/scdIntroToGit](https://github.com/davidmeredith/scdIntroToGit)

[top](#Table-Of-Contents)

[1] [https://github.com/davidmeredith/scdIntroToGit/blob/master/introToGit.pdf](https://github.com/davidmeredith/scdIntroToGit/blob/master/introToGit.pdf)

[top](#Table-Of-Contents)

#### Integrating Upstream Changes

There are two strategies to incorporating upstream commits from other branches - merging and rebasing.Â  Upstream commits are new commits that exist on another branch which need to be incorporated into your current branch to keep the branch up to date:

 a) Periodically merge the changes in the target branch (dev) into your feature branch. This creates the â€˜braidedâ€™ graph pattern show opposite (flow is from top to bottom). When youâ€™re ready to merge dev into master, a new merge-commit is created on the tip of the master branch.

 ![](attachments/Pasted%20image%2020240610204748.png)

b) As shown below, rebasing basically â€˜breaks off the feature branch from its root (yellow), and re-attaches it to the tip of the target branch (grey)â€™. During the rebase, the commits that exist on the feature branch are internally used to create a set of diffs in temporary files which are used by git to create new updated versions of your feature commits. Git needs to do this in order to incorporate any upstream changes that may have occurred on the target branch.

![](attachments/Pasted%20image%2020240610204801.png)

[top](#Table-Of-Contents)

Note that rebasing does not delete the feature branch, the feature branch still exists, but it is now ahead of the target branch, by 2 commits in the diagram below. To bring the target branch up to date, a fast-forward merge is required on the target branch.

![](attachments/Pasted%20image%2020240610204811.png)

[top](#Table-Of-Contents)

#### Rebase vs Merge

Whether to rebase or merge is generally down to preference:

- Use â€˜rebaseâ€™ to produce a clean and linear commit history. You can optionally use â€˜interactive-rebasingâ€™ and â€˜squashingâ€™ to clean up your commits too. Also observe the golden rule of rebasing: Donâ€™t use rebasing if your feature branch is shared amongst multiple developers â€“ rebasing essentially â€˜pulls the rug from the under the feet of the other developersâ€™ working on the feature branch.
- Use merge if you need to preserve a full history, for detailed auditing purposes for example. If this is the case, you probably donâ€™t want to delete the feature branch after merging it, but you can do this later if needed.

[top](#Table-Of-Contents)

### Adopt Semantic Versioning for tags and releases

- [SemVer](https://semver.org/](https://semver.org/)

### Review each others code and be supportive

- Foster a friendly and supportive environment and politely shout-out vulnerabilities and apparent issues, donâ€™t be shy. As a reviewer youâ€™ll learn something. Code reviews and pair-programming really does improve code quality and exposure to different projects/codes/practices.

### If the critical path has not been reviewed it should not go onto master branch

- Basic code quality relies on having at least two pairs of eyes on code, to catch errors, suggest improvements, build shared knowledge, and improve code style.Â  Get into the habit of developing on branches or forks and using pull / merge requests to facilitate code review before merging.

[top](#Table-Of-Contents)

### Continuous Integration - If it does not have tests it does not work

- To be able to say something 'works' we judge it against some (implicit) criteria.Â  Writing tests makes our success criteria explicit.Â  Automation (Continuous Integration) prevents regressions.Â  Eventually, this leads towards test-driven development (TDD) where we think clearly about specifying what 'working' looks like up-front by writing code from a callerâ€™s perspective.
- Test as you go along to a level thatâ€™s feasible and pragmatic. Extensive testing with production-level coverage (70 to 80%) is not always achievable or useful.Â  Given project budgets and timescales, focus on testing the applicationâ€™s critical path as a minimum.
- Avoid gold-plating and focus on shipping code ASAP for customer review & feedback.
- Your Unit tests should be fast to complete â€“ order of seconds.
- Do not just rely on unit tests - system and integration tests are also needed. Unit tests alone will instil a false sense of security.
- Integration and System tests can take longer to complete.
- For more details on best practices for testing, including the different types of testing from Unit, Integration to System tests, see: [https://epubs.stfc.ac.uk/work/50305274](https://epubs.stfc.ac.uk/work/50305274)

[top](#Table-Of-Contents)

### Continuous Delivery

Means that the software should always be in a releasable-ready condition. Â This is a recommendation for your master and dev branches. If youâ€™re run over by a bus (ROBAB), and someone must come along and pick up your code and they must fight with it from the outset, thereâ€™s a strong chance it will become shelfware. Â If you need to have prolonged branches for experimentation that arenâ€™t release-ready, create a feature branch such as â€˜feature:homersSandboxâ€™ to isolate your experiments. [https://epubs.stfc.ac.uk/work/47984368](https://epubs.stfc.ac.uk/work/47984368)

[top](#Table-Of-Contents)

### Continuous Deployment

Means that once the software is merged into master branch, it automatically gets pushed into production. The idea is to make the large and risky â€˜big feature releaseâ€™ a legacy practice.Â  By continuously deploying to production with small and frequent updates, if something goes wrong, its quick and easy to rollback.Â  This might be a stretch for Hartree because its more relevant for long-lived production software & products, not so appropriate for proof of concepts.

[top](#Table-Of-Contents)

### If it Does not have Documentation it is Not Usable

- Publish docs: Jira (task/sprints), Confluent (docs), GitLab, (code, merge requests, CI/CD), Bid register (PMO tracking tools)
- Use xDoc style code comments such as JavaDoc, PyDoc
- Document the intended purpose / intent of a function/class/package.
- If itâ€™s tricky to document the intended purpose, then your class/function is likely too long and needs breaking down into smaller units.
- Always add a README.md.
- Always document inline - we _rarely_ go back and document our code after its written, fact.Â Â 
- End-users need to know how to use our software, so think about the right level of documentation for users. Consider separate user & developer docs.
- The C4 approach to technical diagrams is good. [https://c4model.com/](https://c4model.com/)
- For more details on how to write good documentation for different users including â€˜How Toâ€™ Guides, tools such as Markdown/AsciiDoctor, and reference guide formats, see: [https://epubs.stfc.ac.uk/work/47984356](https://epubs.stfc.ac.uk/work/47984356)

[top](#Table-Of-Contents)

### Learning mindset

- Keep reading & learning and record all your training activities.
- Push beyond your comfort zone.
- Participate in RSE Skills & Learn sessions.
- Keep up the pursuit of software engineering craftsmanship, mastery and professionalism.
- Tinker - its really important to do hobby projects and dev stuff you enjoy.

### Customer Bill of Rights - modified from Uncle Bob Martin Clean Agile

Customers have the right to:

- An overall plan and to understand what can approximately be accomplished and at an estimated cost.
- Get the most possible value out of their projects.
- See progress in the development of a system.
- Change their mind, to substitute functionality, and to change priorities subject to agreement and re-scoping of the plan.
- Be informed of schedule and estimate changes, in time to choose how to reduce the scope to a meet a required date.
- Cancel at any time and be left with useful outputs reflecting their investment to date.

[top](#Table-Of-Contents)

### Developer Bill of Rights - modified from Uncle Bob Martin Clean Agile

- Developers have the right to:
- Know what is needed with clear declarations of priority.
- To always produce high-quality work.
- Ask for and receive help from peers, managers, and customers.
- Make and update their estimates at any time.
- Challenge the task and the responsibilities instead of having them assigned â€“ professionals accept work, they are not assigned work. A professional developer has every right to say no to a particular job for various reasons, from ethical to overloading.
- Knowing â€˜accepting workâ€™ comes with a cost â€“ acceptance comes with responsibility. Â 

[top](#Table-Of-Contents)

### Tooling

#### Do not be Smart - Use the Right Tools for the Job and for your customer

As a centre, we should be using the right tools for the job, we all have our preferences, but thereâ€™s no need to be stubbornly loyal about a particular language or OS. As software professionals, we should recognise the right tools for the job and for our clients. Â 

#### To Garbage Collect or Not To GC

For HPC and when squeezing software into tight spaces such as in low-level systems programming (systems software isnâ€™t HPC BTW), a Garbage Collected (GC) language probably isnâ€™t the best choice. The GC adds lots of memory requirement. However, for full-stack, enterprise-applications / services, mobile, and general-purpose programming, it's probably best to use a memory safe language â€“ â€œA human garbage collector is just wasted effortâ€ (Eckle & Ward, Happy Path Programming). Similarly, there is a recognised shift in industry away from memory unsafe languages as it is widely known that the majority Common Vulnerability Exploits (CVEs) stem from unsafe memory language exploits, causing organisations such as [Google](https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html) (for Android), [NSA and Microsoft to urge the use of memory-safe languages](https://www.theregister.com/2022/11/11/nsa_urges_orgs_to_use/).

Have the customer in mind. For example, Haskell and other Lisps are great (Iâ€™ve played with Clojure), but donâ€™t be smart and use this as an opportunity to explore your favourite pet-programmer project, itâ€™s not going to be much use to the customer. Itâ€™s hard to hire Haskell programmers.

![](attachments/Pasted%20image%2020240611091943.png)

[top](#Table-Of-Contents)

#### Kanban - Jira and Confluence

Keep all project documents and the Decision Point Review templates in a single repo such as Confluence so the client has full visibility. Its best if the client creates the (free) Jira instance and invites us as admins on their Kanban/Jira/Confluence. This way, the client has ownership of the project after the project completes. Make sure you export and download a copy of the Jira archive file so we can restore it within our own Jira instances if needed in future or for follow on projects.

![](attachments/Pasted%20image%2020240611092007.png)

[top](#Table-Of-Contents)

#### Gitlab and Version Control

For Hartree folks: Use the STFC Gitlab instance unless there is good reason not to: [https://gitlab.stfc.ac.uk/](https://gitlab.stfc.ac.uk/)

#### Container Repository

For Hartree folks: Use the STFC Harbor repository to upload and store containers: [https://harbor.stfc.ac.uk/](https://harbor.stfc.ac.uk/)

#### Build Tools

It is the developerâ€™s responsibility to use an appropriate build tool that manages the dependencies of your project. It should be possible to clean the project, download dependencies, re-build a project, run unit and integration tests, and build a deployable package all from the command line. It is also the responsibility of developer to create the necessary environment configuration files (with specific version of modules or libraries) in a consistent state so that someone else can pick up your project easily.

[top](#Table-Of-Contents)

#### Static Code Analysis

Static code analysis helps bring consistency to your code. Within a project, adopt the same style guides and agree the linters up front e.g., Black for Python, Google style guide for Java are good examples. Thereâ€™s no ruling here, pick one that suits the team and be consistent. There are plenty of static code analysis tools out there such as CheckStyle, FindBugs, SonarCube, Black, Google linter, IDE checks.

[top](#Table-Of-Contents)

#### Containerisation for Portability

Containers have become the de-facto way to mitigate the common claim â€œwell, it works on my machineâ€. OCI compliant containers (Open Container Initiative) are great for wrapping code with all their dependencies into shareable images that can be uploaded to image repositories such as STFCâ€™s Harbor service ([https://harbor.stfc.ac.uk/](https://harbor.stfc.ac.uk/)).Â  Containers are a great way to share code with your clients, especially if they need to run your code on their runtime platform. Containers are ubiquitous and can run on the Desktop, in Kubernetes clusters, in cloud Functions such as AWS Lambda, on HPC such as [Apptainer/Singularity](https://apptainer.org/), and more.

Here are some recommendations:

- Only include runtime dependencies: Be mindful of what youâ€™re including in your container - for production, you really donâ€™t need to include compilers, package managers, and tools that are meant for use only at compile time (unless youâ€™re containerising your dev environment of course). For example, [Googleâ€™s Distroless](https://github.com/GoogleContainerTools/distroless) containers and [Alpine Linux](https://alpinelinux.org/) are great for production use, providing cut down versions of Linux.Â  Containers such as these are great because they have less memory-footprint, and by reducing the amount of unnecessary stuff in them, they reduce the vulnerability attack surface, so theyâ€™re safer. [Hereâ€™s a great video](https://www.youtube.com/watch?v=6wYrAtngIVo) that shows how to build super slim production containers â€“ ignore the fact that it is for Java, the concepts and tools discussed are generic and apply for many languages.

- Donâ€™t statically link glibc â€“ use the [musl](https://musl.libc.org/) library instead. Glibc is notoriously unfriendly for containerisation and was not designed to be so.

- Donâ€™t run your code within the container using the root user unless you really must.

- Use image layering to split up build time and run time dependencies. For example, having a separate 'build' and â€˜runâ€™ layers in your docker file allows you to copy only the built application code and dependencies into the container, leaving out all the unnecessary compile time dependencies. It also means you can re-run the container more quickly without having to re-build each time as build layers are built and cached locally.

- Testcontainers is awesome, download and run containerised apps/dependencies such as databases, services, tools and use them in your integration-test suites. Comes highly recommended: [https://www.testcontainers.org/](https://www.testcontainers.org/)

- See this great guide from the RSE team [for more info](https://softwareoutlook.ac.uk/best-practices-in-software-engineering/) on how to run HPC Singularity (now [Apptainer](https://apptainer.org/)) and Conda images with worked examples.

[top](#Table-Of-Contents)

#### Workflows and Containerisation

Please refer to this separate document that characterises all the different types of workflows we use at Hartree, including Data Flow Engines that orchestrate containers using DAGs (Directed Acyclic Graphs): [http://purl.org/net/epubs/work/50844906](http://purl.org/net/epubs/work/50844906). Our â€˜[Demystifying Data Engineering](https://www.hartree.stfc.ac.uk/events/demystifying-data-engineering/)â€™ Explain course provides more details into Data Flow runtimes and tooling.

[top](#Table-Of-Contents)

## Coding Recommendations and Best Practices

This is not an exhaustive list of coding recommendations. For more in-depth explanations, please see the list of highly recommended texts in the appendix. Iâ€™m not going to repeat all that excellent advice here, thatâ€™s what the books are for, but please find below a collection of development best practices that we should consider when developing our software. Like all guidelines, they arenâ€™t strict rules, knowing when and where to apply largely comes down to experience.

[top](#Table-Of-Contents)

### High quality code is easy to change

Code needs to achieve its purpose under certain parameters, but assuming that it does, what is high quality code?  There are many definitions, but I like "high quality code is easy to reason about and change."  It implies the code is readable, it has good abstractions with well named constructs (classes, functions, variables, packages etc), and overall it is maintainable.  

[top](#Table-Of-Contents)

### Quality is the best shortcut - Fowler Design Stamina Hypothesis

- Think carefully about compromising the quality of your code for delivery speed; high quality code quickly becomes easier and faster to develop and overtakes hastily hacked together code. This is evidence based, see Martin Fowler's [Design Stamina Hypothesis]([https://martinfowler.com/bliki/DesignStaminaHypothesis.html](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)) which describes how the velocity of software development declines with time due to poor design. We have also experienced this before in actual projects â€“ the hypothesis has played out in practice at Hartree.

![](attachments/Pasted%20image%2020240611092227.png)

[top](#Table-Of-Contents)

### Do Not Name Abstractions After Constituent Parts

- Do not name abstractions after their constituent parts using a 'bottom up' approach. By definition, an abstraction should use a higher level vocabulary and shield you from the lower level details. Gregor Hohpe from Enterprise Application Integration book fame provides a great example: If software engineers had named the automobile, it would have been something like: `PistonCrankshaftGearWheelAssemblyFactorySingleton` - not a useful name (this reminds me of some Spring Framework classes).  Another simple example from Gregor: Q. consider the `GasPedal` of the car, is that a good abstraction? A. no, the car might not use gas, a more suitable name is the `Accelerator.`     

[top](#Table-Of-Contents)

### Naming with Meaningful and Descriptive Names 

- â€œThere are only two hard things in computer science, invalidation and naming thingsâ€ (P.Karlton), see: [https://martinfowler.com/bliki/TwoHardThings.html](https://martinfowler.com/bliki/TwoHardThings.html)
- Use intention revealing names for your abstractions, classes, functions & variables, and donâ€™t use single character variable names (single chars for implicit loops etc are OK, but for global/module/class members, please use sensible names).Â  For example, `process_model` is too generic, what does it mean? `execute_nlp_training_model` is better, its more self-documenting.
- Class names should have noun phrases e.g., Customer, WikiPage, Account, AccountParser.
- Donâ€™t use a comment when you can use a well named function or variable:
  

![](attachments/Pasted%20image%2020240611092516.png)

[top](#Table-Of-Contents)

### Testing has Three Main Purposes

a)Â Â Â Â  **To assert the correctness of your code**. Sometimes you might counter â€œwell, itâ€™s not always possible to know the result of a calculation to assert because the result is non-deterministicâ€.Â  In this scenario, the following reasons to test still hold true!

b)Â Â Â Â  **To prevent regressions.** It really does build confidence in your code if you can quickly run a test suite to make sure you havenâ€™t unexpectedly broken something.

c)Â Â Â Â  **To encourage good design.**  It _really_ does actually - thereâ€™s lots of supporting research that shows this. When you write tests, you put yourself in the caller perspective, so you really do think about design such as loose coupling, separation of concerns, modularity, simplicity of API, and so on. If your code is hard to test, itâ€™s likely too strongly coupled, and here Dependency Injection with abstractions can help you. Â Test Driven Development (TDD) is the ultimate testing practice, where you write tests first using an imaginary API, and then you fill in the details.

[top](#Table-Of-Contents)

### Keep Classes and Functions Smallish

General rule â€“ not much bigger than your screenâ€™s viewport. I don't subscribe to certain author's view that functions should be no longer than four or five lines myself - I find it too difficult to hop around the code when functions are this small.   However, a viewport size / page is fine, and if you still need convincing, know that compilers can apply far more effective in-lining optimisations with smaller classes and functions.

[top](#Table-Of-Contents)

### Limit the Number of Function Arguments

Consider using immutable Data Transfer Objects (aka DTOs / Data Objects / Records) if your function has more than ~4 arguments.

### Functions should do one thing and do it well

Separation of concerns at the function level.

### Classes and Code Should be Cohesive

Classes should be cohesive â€“ high cohesion means the methods and variables of the class are co-dependent and often change together. This can be paraphrased as "Changes to the code over here should not affect code over there" and/or "Code that changes together stays together. "

Hereâ€™s the authoritative view from the famous [Kent Beck from Nov (2022) and his â€˜Tidy Firstâ€™ approach to software development:](https://twitter.com/KentBeck/status/1587825849755049984)

![](attachments/Pasted%20image%2020240611092926.png)

Examples of patterns that support cohesion include the State Pattern.

- In the State pattern, consider code that is widespread across many files that has exhaustive 'switch' or 'when' statements that reference a centrally declared enum set. The exhaustive switch/when statements execute different behaviours based on the current enum state value. If you add or remove a state enum option, you will need to update the exhaustive switch/when statements spread across your code-base. This is not a problem for small projects, but for large code bases it can require significant refactoring. The state pattern co-locates the state enum values with the dependent behaviour i.e., "things that change together, stay together." As an example, the central enum set could be replaced with a corresponding set of state objects, where each state object collects and implements the relevant state-dependent behaviour itself. There are several ways to implement this depending on you language of choice.  

[top](#Table-Of-Contents)

### Classes should have only one reason to change and do one thing and do it well

- Separation of concerns at the class level.

### OOP Redefined 

OPP is about "Program organsiation" (Bjarne Stroustroup). 

The OOP data model of class inheritance hierarchies and interface implementations has, undoubtedly, proven to be highly effective in modeling real-word data, largely due to its frequent natural fit for representing real-world objects, and also due to its expressiveness. OOP still dominates compared to other programming paradigms such as functional and procedural. OPP helps you to organise programs around data and the actions that are intended to operate on that data. From my perspective, what I like about OOP is that it is really clear how to organise my program around classes - locating the data alongside the functions that operate on that data is very common and often feels natural. Without classes, you can lose some of this clarity, especially in large programs. However, OPP is not the only option. Other paradigms such as Functional, Procedural, and Data Orientated Programming exist. I'm not a pureist - I believe you can and should apply all these paradigms when it is most convenient to do so. Most general purpose programming languages allow you to mix paradigms to some extent. 

OOP bashing appears to be popular these days, but this is mostly because of the problems associated with heirarchical inhertiance (see section on Don't Pay Too Much Inheritance Tax), and I agree that heirarchical inhertiance should be applied judiciously. However, I believe that most of the other OOP principles are tried, tested, and proven. You canâ€™t argue against three of the four 'pillars' of OPP: Abstraction, Encapsulation, and Polymorphism. These are good design principles largely available across all modern programming languages.Â  Arguably, what pure OOP can over-emphasise is deep & brittle inheritance hierarchies, but insteads you can favour composition instead in the right scenarios.

| Pillar | Implementations|
| -------------- | --------------- |
| Abstraction | Interfaces, Traits, Service Facade, Closures |
| Encapsulation | Classes, Records/struts/nested-structs, Closures, Modules, Public/Private/Protected visiblity|
| Polymorphism | Inheritance, Type-classes, Generics & Parametric Polymorphism, Interfaces/Traits, Dynamic-Dispatch |
| Inhertiance| Replace with 'Code Sharing' with impls inc. Compostion/Delegation, Traits, Interfaces  |

I belive Inhertiance should be replaced with 'Code Sharing': the other pillars are generic to accommodate multiple implementations and inhertiance is not the only way of sharing code across types. Other ways to share code incldue Composition (avaialble any language), traits (Scala, Rust), interfaces with default implementations and attributes (Java, Go, Py), and type-classes (Scala), to name a few. I agree that inheritance can be overdone, but it does have it place (see section on 'Don't pay too much inheritance tax').  

### SOLID

For OPP, understand the principles of SOLID:

- Single Responsibility Principle
- Open for extension, closed for modification 
- Liskovâ€™s Substitution principle (Barbara Liskov)
- Interface Segregation principle
- Dependency Inversion

[top](#Table-Of-Contents)

### Polymorphism Redefined

What does polymorphism mean to you? For those with background in OPP, you most likely think of inhertiance using an abstract base-classes with sub-type specialisations. However, I agree with [Bruce Eckle](https://www.youtube.com/watch?v=ojffu0F_aQQ) in that it is more than that, polymorphism crops up everwhere: 

> [!TIP]
Don't limit your understanding of Polymorphism to inheritance alone, it broadly means that 'a single type can represent multiple types,' typically through dynamic-dispatch.

If we acknowledge this interpretation, then polymorphism can include: 
| Polymorphism type   | Description|
|--------------- | --------------- |
| Sub-Type Polymorphism   | Classic inheritance with base class & sub-type specialisation  |
| Union/Sum Types  | A type must be one from a selection of types (choice)|
| Parametric Polymorphism | Code **attached to an existing type** to represent another type, typically via genercis|
| Structural Polymorphism/Protocols/DuckTypes | A type is **compatible** if has methods/attributes defined by a protocol|

 
#### Inheritance should be explicitly designed-for

In many languages, you can extend a class by default, unless you explicitly disallow it e.g., using the `final` keyword in Java or through sealing. In more modern languages, classes are closed to extension by default.  For example, in Kotlin you have to explicitly enable class extension using the `open` keyword to make it explicit that this class is designed to be extended. This makes SOLIDâ€™s 'Open for Extension, Closed for Modification' best-practice explicit in the language. Â 

[top](#Table-Of-Contents)

#### Avoid Paying too much Inheritance Tax - Use Parametric Polymorphism to Augment your Type-System

- Deeply nested inheritance hierarchies where sub-classes extend super-classes can be brittle. This is because you are structurally tied to the classes in the parent hierarchy - if you don't need all of the behaviour provided through inheritance, it can be difficult to 'split-out' the behaviour that you do not need without widespread refactoring. If you don't have access to the src of the parent hierarchy, this can force you to implement abstract methods for methods you don't need by typically throwing unsupported exceptions/errors.Â If you do have access to the src of the parent hierarchy, you may need to extract the required methods into a new level in the inheritance hierarchy and inherit from that appropriate level e.g., from the direct parent if you do want those methods, or from a higher-level ancestor if you do not need every method. This can be an expensive refactor meaning deep inheritance is often considered an anti-pattern these days, especially for application developers. A number of modern languages don't even support inheritance. Having said that, inheritance definitely does have its place when developing libraries and frameworks, and especially for relationships that have a strong and natural "Is a" type of relationship e.g., 'typeA is a genuine / real sub-type of typeB.'

> [!TIP]
Rather than pay too much inheritance tax, consider using 'Parametric Polymorphism' where a type can implement some shared code which allows that type to be represented as another type. This shared code augments your type-system with new polymorphic types for use in function parameters, return values, and attribute declarations, often in conjunction with generic 'holder types' such as Generics. The canonical name for this type of polymorphism is "parametric polymorphism" or "generic programming." 

The mechanism for sharing code subtly varies across languages and includes Interfaces (eg Java), Traits (eg Rust), Mixins (eg Python), and Type-Classes (eg Scala). I like the term 'Type-Class' because it is expressive of its intent: by attaching behaviour to an existing class, you can use the existing class as a new type.

> [!TIP]
I say "don't pay too much inheritance tax" intentionally because at can be argued that inheritance does still have its place, especially in building frameworks and for strong/natural "Is a" relationships e.g. "type A is a type of B."

- Several modern languages donâ€™t even support inheritance (Rust, Zig, Go), relying instead on parametric polymorphism.  

#### Parametric Polymorphism Attaches Behaviour To Custom and Existing Types

Some languages allow you to 'attach/graft' shared behaviour onto existing types where you don't have access to the src code of those types. For example, new types can be introduced through library imports. Rust, Scala, and Go all lexically split their type definitions from the attached behaviour definition using an additional 'referencing-layer' that attaches the behaviour to the type. 

> [!TIP]
Attaching behaviour to a type through an extra 'referencing layer' is elegant and more powerful than implementing shared behaviour directly on a type, such as implementing an interface directly on a class. This is because you don't need to modify the existing type. If that extra layer of indirection feels a touch unnatural or overkill, you can easily co-locate these individual component parts near to each other in the same file to achieve that familiar class feel.

A Rust example is shown below:

<img src="attachments/Pasted%20image%2020241027141335.png" style="width:400px;"/>

While Rust-like traits are elegant and powerful, you can achieve a similar effect using a combination of interfaces with default method implementations and composition, a Java example is shown below. As you can see, there is a lot more fuss, and this is still not as powerful as Rust-like traits which allow automatic 'blanket' implementations, trait-inheritance, and IDE dot-completion/suggestions. 

```java
// Trait (interface) definition - similar to a Rust trait
interface Printable {
    // Default method implementation - similar to Rust trait methods
    default String prettyPrint() {
        return "[" + toString() + "]";
    }

    // Abstract method that implementing classes must define
    String format();
}

// Extension method for adding functionality to existing types
interface StringExtensions {
    // Default method that can be "mixed in" to any String
    default String truncate(int maxLength) {
        if (this.toString().length() <= maxLength) {
            return this.toString();
        }
        return this.toString().substring(0, maxLength) + "...";
    }
}

// Example class demonstrating trait-like behavior
class User implements Printable, StringExtensions {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Implementing the required method from Printable
    @Override
    public String format() {
        return name + " (Age: " + age + ")";
    }

    // Optional override of prettyPrint if needed
    @Override
    public String prettyPrint() {
        return "User: " + format();
    }

    @Override
    public String toString() {
        return name;
    }
}

// Demonstration class
public class TraitDemo {
    public static void main(String[] args) {
        User user = new User("Alice", 30);

        // Using default method from Printable trait
        System.out.println(user.prettyPrint());

        // Using default method from StringExtensions trait
        String longString = "This is a very long string that needs truncation";
        System.out.println(((StringExtensions) longString).truncate(10));
    }
}
```

[top](#Table-Of-Contents)

Compared to Rust, Kotlin provides a similar approach to traits through combination of interfaces with default methods and extension functions, providing a very powerful type system that can be augmented. 

```Kotlin
// Rust-like trait implemented with a Kotlin interface with default methods & extension functions
interface Printable {
    // Default method implementation similar to Rust trait methods
    fun prettyPrint(): String {
        return "[$this]"
    }

    // Abstract method that implementing classes must define
    fun format(): String
}

// Extension function to add functionality to existing types
// This is similar to Rust's trait methods that can extend existing types
fun String.truncate(maxLength: Int): String {
    return if (length <= maxLength) this 
    else substring(0, maxLength) + "..."
}

// Extension function with more complex logic (see section on Exension Functions)
fun String.wordCount(): Int {
    return trim().split("\\s+".toRegex()).size
}

// Sealed class to demonstrate trait-like behavior (see section on Sealing)
sealed class ValidationResult {
    data class Success(val message: String) : ValidationResult()
    data class Failure(val error: String) : ValidationResult()
}

// Trait-like interface for validation
interface Validatable {
    fun validate(): ValidationResult {
        // Default implementation
        return ValidationResult.Success("Default validation passed")
    }
}

// Data class implementing multiple "traits"
data class User( val name: String, val age: Int) : Printable, Validatable {
    // Implementing required method from Printable
    override fun format(): String {
        return "$name (Age: $age)"
    }

    // Optional override of prettyPrint
    override fun prettyPrint(): String {
        return "User: ${format()}"
    }

    // Custom validation implementation
    override fun validate(): ValidationResult {
        return when {
            name.isBlank() -> ValidationResult.Failure("Name cannot be blank")
            age < 0 -> ValidationResult.Failure("Age cannot be negative")
            else -> ValidationResult.Success("User is valid")
        }
    }
}

// Demonstration of type augmentation and trait-like behavior
fun main() {
    // Demonstrate extension functions
    val longString = "This is a very long string that needs truncation"
    println(longString.truncate(10))
    println(longString.wordCount())

    // Demonstrate trait-like behavior with User
    val user = User("Alice", 30)
    
    // Using methods from different "traits"
    println(user.prettyPrint())
    println(user.format())
    
    // Validation demonstration
    val validationResult = user.validate()
    when (validationResult) {
        is ValidationResult.Success -> println("Validation passed: ${validationResult.message}")
        is ValidationResult.Failure -> println("Validation failed: ${validationResult.error}")
    }

    // Trait-like composition and extension
    val users = listOf(
        User("Alice", 30),
        User("Bob", 25),
        User("Charlie", 35)
    )

    // Extension function that works with collections
    fun List<User>.filterValidUsers(): List<User> {
        return filter { it.validate() is ValidationResult.Success }
    }

    println("Valid users: ${users.filterValidUsers()}")
}
```

#### Extension Functions for Augmenting Existing Types

Some languages allow you to extend the functionality of existing types using extension functions e.g., C# and Kotlin. Extension functions can be grafted onto existing types even if you don't have access to the src code for those types. Notice that in the example below, the `method` is grafted onto the `GenericTrait` interface, outside of the class declaration, so that all other implementations of `GenericTrait` can call `method`. 

![](attachments/Pasted%20image%2020241027144154.png)

[top](#Table-Of-Contents)

#### Structural Polymorphism and Duck Typing

Some languages have have â€˜Duck Typing,â€™ this is like using an interface at the call site but does not require you to explicitly define a contract on a type using scaffolding code such as `implements interface` or `impl trait for`. Instead, if a function defines a particular type and the type that is passed into the function has the corresponding functions available, those functions will be invoked: â€œif it walks and swims like a duck, itâ€™s probably a duck,â€ otherwise a runtime error is generated. Â This is also known as â€˜Structural Polymorphism.â€™ It is generally more common in dynamic languages, but C++ has it too through `Template` classes with the advantage of compile-time checks.  

>[!TIP]
The ease and speed of development that duck typing brings is great for scripting and smaller code bases, but as the size and complexity of the code increases, I would advise using scaffolding code for stronger compile time type checking (for Pythonistas, you can always introduce static typing such as Pythonâ€™s optional type hints). 

[top](#Table-Of-Contents)


### Sealing 

Some languages allow the developer to seal interfaces/classes/types in order to restrict the range of allowed subtypes. 

>[!TIP]
Why sealing? Limiting the extensibility of types is a useful feature for domain modelling when code reuse is not a goal. Instead, the restriction of subtypes to a known set helps comprehension, clarity, type misuse, and security. Sealing mitigates the need for defensive coding for unknown subtypes, and is useful for increasing the security of libraries. It facilitates exhaustive `when` and/or `switch` case patterns for Algebraic Data Types (see ADTs below).

As a simple example, consider a sealed result class that has a fixed number of subtypes to indicate different kinds of results. You can react to the different results via exhaustive when/switch patterns. In another domain modelling example, consider subtypes of the class `Shape` - the author may be interested in the clarity of code that handles known subclasses of Shape, and is not interested in writing defensive code for unknown subclasses of `Shape`.

[top](#Table-Of-Contents)

### Composition / Delegation

A complex term that in practice simply means that one class contains or is passed an instance of another to use its capabilities. Different languages do this in slightly different ways. 

> [!WARNING]
Unless your language supports duck-typing, composition alone may not establish a polymorphic type without the addition of additional scaffolding code such as an interface or trait. 

- Object composition and parametric polymorphism might be the only option available to you, especially if you donâ€™t own the source-code of the object you want to augment. Therefore, the only way to extend such an object is to compose it within another object and hide its functionality behind scaffold code such as interfaces.

[top](#Table-Of-Contents)

### Data Orientated Programming vs OOP - Choose Two 

If you can do OOP, you can do DOP: DOP advocates for cleanly separating data from class methods. Data is typically modelled using hierarchically nested structs/records/data-objects. Behaviours that operate on the data are typically extracted into top-level or module/package level functions. Note, this does not include data validation and invariant checking logic - it perfectly valid (preferable) to co-locate initialisation and validation logic with your data classes, in class/record constructors for example. DOP tends to adopt more noun orientated naming approach whereas OPP tends to adopt a mix of nouns and verbs. 

### Functional vs OOP - Choose Two

To quote Eric Evans, an expert in both OOP and Functional paradigms and of 'Domain Driven Design' book fame: "At times, I found FP an awkward fit. The problem would have fit OOP better. I'm happy that it is easier than it used to be to move between both those ways of thinking." 

I completely agree with Eric - if the language permits, combining functional approaches with OOP is convienent in the right scenario. Within the same code base, the recommendations are: 
- Use a naming convention to identify pure functions (see below on 'Calculations to limit side effects')
- Push out side effects to the out boundaries of your code (see the Dependency Rule / Bullseye) so they become 'intended effectsâ€™ and not nasty interleaved â€˜side effectsâ€™.
- Aim for a core of pure functions.

Well worth a watch: [https://www.youtube.com/watch?v=HSk5fdKbd3o&t=543s](https://www.youtube.com/watch?v=HSk5fdKbd3o&t=543s)

[top](#Table-Of-Contents)

### Dependency Inversion Principle

See the next two slides below. If this does not make sense, please refer to the texts above, but in short it says, â€˜donâ€™t depend on implementation details, depend on abstractions between boundaries in your codeâ€™.

![](attachments/Pasted%20image%2020240611093615.png)

[top](#Table-Of-Contents)

![](attachments/Pasted%20image%2020240611093638.png)

[top](#Table-Of-Contents)

### Dependency Injection and Inversion of Control for Decreasing Code Coupling - IoC

Basically, this means that your application code does not itself create instances of classes directly. Instead, these objects are created separately by 'wiring logic' that sits outside of your immediate business/domain code. As a result, business and domain objects are then automatically injected into other business/domain objects. Injection occurs via class-constructors for required dependencies, or setter methods for optional dependencies. The wiring code can be implemented manually using the *Factory Pattern* or using an *Inversion of Control* containers such as [Spring.io](https://stfc365.sharepoint.com/sites/HartreeRSEPublic/Shared%20Documents/General/spring.io). 

For the most part, the lifetime of a class is typically either singleton-scoped a.k.a., â€˜application scopedâ€™, where a single instance is created and managed (which means it must be thread-safe), or â€˜prototype-scoped,â€™ where a new instance is always created & injected. However, there are several other specialised lifetimes such as â€˜session-scopeâ€™ or 'transaction-scope' depending on your requirement.

So, what is the benefit of IoC?Â 
- Separation of Concerns: First, the â€˜wiring logicâ€™ is cleanly separated from your domain logic; wiring logic resides in Factory classes or is managed by the IoC container.
- Decreased Code Coupling: This really is an excellent approach for decreasing _code coupling_ if you use abstractions/interfaces. Dependent code only needs to know about higher-level abstractions, not concrete details. This really helps reduce complexity.
- Late Binding: By not depending on concrete classes, it creates the opportunity for IoC to read in class libraries that have been dynamically dropped into your server at runtime without having to make any changes to your logic (see late-binding).
- Advanced Life Cycle Management: The wiring code in your IoC container or Factory can be used to manage the *life cycle* of your dependencies which enables several possible optimisations and actions. For example: 
  - 'Just in time' creation of objects enables late-binding for dynamic use-cases such as dropping in new libraries without server re-start, 
  - Objects can be cached within object pools which helps reduce potentially expensive object creation for increased performance. 
  - Managing the life cycle of objects outside of your injected classes provides a 'point-cut' for custom actions. For example, when an object is returned to the pool, you can fire an event, for example.
  - Object destruction can be handled under an external managed process.
- More effective testing: You can mock different dependencies/classes and inject them into your objects as needed to test different scenarios. A very simple example from Dave Farleyâ€™s â€˜Modern Software Engineeringâ€™ book is given below:

[top](#Table-Of-Contents)

![](attachments/Pasted%20image%2020240611093717.png)

For the `Car` class, unless we decide to break encapsulation and make `engine` public, you canâ€™t test the engine separately.Â  Our `BetterCar` allows you to mock or create a different engine implementation and test that separately as shown below:

![](attachments/Pasted%20image%2020240611093737.png)

[top](#Table-Of-Contents)

### Dynamic Late Binding vs Static Binding 
This is a big topic, but as ever, there are trade-offs between the different approaches which ultimately depends on your use-case:

- *Dynamic/late binding:* Allows new code to be deployed without having to re-build and re-start your runtime. This literally means that your application code can evolve over time without re-building and re-starting your application. To do this, you require a dynamic language and runtime such as languages built on the JVM, JS, C# Python and Ruby. A classic example of a dynamic application is Minecraft where player-made mods or custom maps and APIs can be added to a running Minecraft realm. Another example where late binding is for applications that have plugins, this is common in business applications that need to be easily extended such as adding new file parsers or algorithms without having to re-build and re-start the app server. Typically, new functionalities are loaded using *class loaders* through special pluggable library files e.g., `.jar` files containing *dynamic proxies* and implementations of *Service Provider Interfaces* (SPIs). For these types of use-case, late binding is very powerful, but in my opinion, for the majority of applications, it is overkill. Late binding is commonly implemented using a technique called *reflection* which is not as performant as static binding because code needs to be introspected in order to invoke the new functionality. Polymorphism also allows method overriding for new sub-types to be loaded at runtime using *dynamic dispatch*. A classic example is dynamically loaded component pallets containing new object sub-types.

[top](#Table-Of-Contents)

Classic examples of dynamic applications include: 
  - *Game Engines* like Unity and Unreal Engine use dynamic binding to load and unload game assets, scripts, and plugins at runtime which enables modular game development and creation of customizable games.
  - *Web browsers* that interpret and execute JavaScript code dynamically to enable web sites to create interactive web pages.
  - *AI and Machine Learning Frameworks* often use dynamic binding to load and execute different models and algorithms at runtime, allowing for experimentation and customization 
  - *Virtual machines* like the JVM and the .NET CLR (Common Language Runtime) use dynamic binding to load and execute classes at runtime.
  - *IDEs* like Intellij IDEA use dynamic binding for their plugins.
  - *Frameworks* like Spring often rely on dynamic binding to allow developers to extend the framework's behaviour without modifying its core code. For example, you can create custom components and inject them into the framework's configuration.
    - DI/IoC containers have changed a lot recently. In the past, they have largely been built for dynamic binding using reflection, but these days you can choose the IoC implementation depending on your requirements, dynamic or static.  
  - *Security applications* for applying patches and updates without restarting. 
  - *Operating systems* like Windows and Linux use dynamic loading to load device drivers and system libraries at runtime. 

- *Static binding:* If you do not need to modify runtime behaviour with plugins or highly dynamic late binding, for the majority of simpler use cases choose static binding for more performant Ahead of Time (AOT) compilation. Late binding is generally more secure considering the additional potential to load malicious code. 

[top](#Table-Of-Contents)


### It Should Not be Possible to Create an Object in an Invalid State

Nuff said. Just to be clear, you should not be able to construct an object in a partially valid state. 

### Know Some Design Patterns

There might be a tried & tested design pattern for the problem youâ€™re tackling. Some patterns are probably overkill, but some genuinely useful patterns include Factory, DTO, Observer, Strategy, Singleton, Repository, Stateless FaÃ§ade, Visitor. Have a look at the recommended texts in the appendix. GoF is kinda regarded as old school these days.

![](attachments/Pasted%20image%2020240611094028.png)

[top](#Table-Of-Contents)

#### The Strategy Pattern Example

This pattern abstracts logic behind a common abstraction such as a SAM interface (Single Abstract Method interface) so that an implementation can be **chosen at runtime**. This makes the code more flexible and reusable. In the Kotlin example below taken from [Dave Leeds](https://www.youtube.com/watch?v=-Ak44LFwlwI&t=64s), we use validation as an example, where any of the validators can be passed at runtime to the FormField class.

![](attachments/Pasted%20image%2020241016180911.png)

[top](#Table-Of-Contents)

Here are two more Kotlin examples that are more idiomatic which reduce boilerplate, again from Dave Leeds:

![](attachments/Pasted%20image%2020240905162859.png)

An even more concise example:

![](attachments/Pasted%20image%2020240905163103.png)

Note you can use an extension function to easily create an optional version:

![](attachments/Pasted%20image%2020240906135416.png)

At the call site:

![](attachments/Pasted%20image%2020240906135400.png)

[top](#Table-Of-Contents)

#### The Visitor Pattern

The visitor pattern is used to separate business logic from objects on which they operate. Typically, objects define an accept method then call method(s) on the accepted visitor. The calling object is typically passed to the visitor as an argument so the visitor can access the object's public state, as in the pseudo code: `accept(Visitor v) { v.visitDoLogic(this); }`.   New logic can easily be added to the visitor's `visitDoLogic(callerObj)` without having to update the calling objects which illustrates an example of the open closed principle in SOLID.   This pattern uses a double-dispatch logic: first an object's `accept(Visitor)` method is invoked, then the visitor's `visitDoLogic(obj)` method second.

The visitor pattern is typically invoked for large cascading / nested object trees; an `accept` method can pass the visitor instance to all its member objects that also define an accept method, for example:

```c#
public class Addition : Expression {
  public Addidtion(Expression left, Expression right){
    Left = left;
    Right = right;
  }
  public override void Accept(Visitor v) {
    Left.accept(v);
    Right.accept(v);
    v.vist(this);
  }
 // get values etc elided 
}

// invoking code would create a Visitor implementation and invoke the double dispatch logic by calling `Addition.Accept(visitor);`
```

[top](#Table-Of-Contents)

Languages implement the visitor differently. For strongly typed polymorphic languages that support method overloading (Java, C#, Kotlin), interfaces can be used simplify the double dispatch logic where `accept` and `visit` methods can be overloaded using different argument types.  Languages that do not support polymorphic overrides e.g., Go and Python, typically need to define different visit-method names e.g.

```Go
type Visitor interface {
 visitWheel(wheel Wheel) string
 visitEngine(engine Engine) string
 visitBody(body Body) string
 visitCar(car Car) string
}
```

[top](#Table-Of-Contents)

#### Builder Pattern for More Complex Object Creation Scenarios

Builders are especially useful if the dependencies of your class have complex invariants. Basically, this means that if you class can only be constructed with a particularly complex combination of dependencies such as â€˜my object requires A and B and either C, D, or E and F, but never G if D is presentâ€™ (Iâ€™m sure you get the idea), then the Builder pattern can help you. How to implement this in your chosen language varies of course e.g., in Go check out the [Functional Options Pattern](https://www.youtube.com/watch?v=MDy7JQN5MN4) where you pass functions to modify the state of a struct. This is a nicely explained example, but it has some issues, first it lacks a `build()` function that is typically used to validate invariants before returning a valid 'built' instance. Second, having a bunch of standalone functions in the Functional Options pattern gives poor discoverability, it can make more sense to use a Builder type bunch of setter functions to set invariants - this means you can easily discover and chain setters using dot notation and code-completion e.g. with pseudo code: `configOps = NewConfigOptionsBuilder().id("someId").maxConnections(10).prefix("somePrefix").build()` e.g. [builder pattern in Golang]( https://dev.to/kittipat1413/understanding-the-builder-pattern-in-go-gp9) 

[top](#Table-Of-Contents)

### Information Hiding

Your first instinct should be to make a method/member/variable private first, then increase visibility as required, not the other way around.

### Keep it Simple Stupid KISS

Bugs can't hide in simplicity. 

### DRY Do not Repeat Yourself

Duplicating chunks of code is odorous - donâ€™t do it.

### YAGNI You Are not Going to Need It

Following Agile processes (i.e., â€˜Feedback Driven Developmentâ€™) should trap and prevent unnecessary code.

### Comment in line As You Go

You donâ€™t retrospectively comment your code, you just donâ€™t. Using sensible names should prevent long-winded doc strings.Â  Use xDoc tools e.g., PyDoc, JavaDoc, xDoc etc. Document the _intent_ of the function/class, not the implementation details.

[top](#Table-Of-Contents)

### The Boy Scout Rule

Leave code in a better state than you found it & donâ€™t comment bad code, re-write it with good descriptive names.

### Law of Demiter and Train Wrecks

A module should not know about the innards of the objects it manipulates (by â€˜objectsâ€™, I donâ€™t mean immutable DTOs / records / data objects, structs, I mean genuine objects that have behaviour that works on their state). [https://en.wikipedia.org/wiki/Law_of_Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter)

![](attachments/Pasted%20image%2020240611094151.png)
From Uncle Bobâ€™s â€˜Clean Codeâ€™

[top](#Table-Of-Contents)


### Do not pollute Functional Code with Mutable State

importantly, keep functional call chains pure; you really donâ€™t want to pollute your functional code with shared mutable state across threads. Consider the following example - one is broken, the other is ok, the difference is subtle. Â So, while combing FN + OOP is powerful, be very careful.

![](attachments/Pasted%20image%2020240611094242.png)

`ParallelStream` will split work across a thread pool, this means the list, which is not atomic and is our external mutable state, is subject to a whole host of complex threading issues (overwrites, ghost-reads, race conditions etc). Replacing the `forEach` with a functional â€˜reducerâ€™ operation (e.g., `toList()`) and converting the call chain from a statement to an expression solves the issue - there are no statements in _pure_ functional code.

[top](#Table-Of-Contents)

### Make Private your Default Class Level Visibility

Modern languages make class members private by default, at the individual class level. Older languages like Java make member variables private at the wider package level by default, which is too visible  in my opinion.   Recommendation is to make members private at the class level. 

[top](#Table-Of-Contents)

### Make Immutability your Default

- Global Mutable State is evil and will eventually cause you problems.
- Modern languages are immutable by default, for example, in Rust and Kotlin, you need to specifically â€˜opt intoâ€™ mutable variables using special keywords such as â€˜mutâ€™ and â€˜valâ€™ (immutable) instead of â€˜varâ€™ (mutable).

[top](#Table-Of-Contents)

### Interior Mutability

When mutability is necessary, try to encapsulate it within a function so any mutable state is not leaked. This is known as â€˜Interior Mutabilityâ€™. Â To do this, youâ€™ll likely need to take defensive copies of the input parameters to reduce the risk of side effects.

[top](#Table-Of-Contents)

### Use Calculations Where Possible to Limit Side Effects

Calculations or â€˜pure functionsâ€™ have no side effects and are â€˜idempotentâ€™. This means given the same input arguments, idempotent functions will return the same value regardless of _when_ you call them (incidentally, this means you can cache the results of expensive calls in a lookup table, for example).Â  Operations may have side effects such as updating a database, writing a file to disk, calling a remote service, even printing to the console is a side effect (maybe another process is reading your stdout/err?). Operations return values may change depending on _when_ you call them. For example, consider calling a travel service with the same function parameters â€“ results will probably vary depending on the time of year or time of day. One approach to help make code that depends on randomness (e.g., a random number is required), is to provide a seed value, and make that part of the external API which allows you to test using the same seed values.

[top](#Table-Of-Contents)

### Separate Operations from Calculations

See prior bullet. Functions should either do something such as create side effects (operations) or provide an answer to something such as returning a result from a stateless calculation. Try to separate functions that have side-effects from pure functions (aka calculations) using a naming convention. Try not to do both in a single function. Â In some languages you can be explicitâ€“ e.g., in Kotlin, a common convention is to reserve single expression functions only for calculations â€“ you can quickly/easily see this in the first line of the expression function signature â€“ no need to understand the function body for side effects. Nevertheless, unless you are using a pure functional language, this is still only a convention.

[top](#Table-Of-Contents)

### Error Handling

#### Error Handling - 4 Types of Problems

1.Â Â Â Â  Unrecoverable problems: Is the error recoverable? If not, then let the program crash. For example, a FileNotFound exception/error/panic should crash if that file is the application's mandatory config file - you can't continue without it.

2.Â Â Â Â  Recoverable problems: For example, if a remote service is temporarily unavailable, you could introduce a retry before showing an error to the user.

3.Â Â Â Â  Errors that need to propagate to the user: Â An error-as-value would be suitable if you are building a file-explorer GUI - you donâ€™t want your program to crash if a file gets deleted by another process. In this scenario use a value-error or catch the exception and convey a sensible message to the user.

4.Â Â Â Â  Programming mistakes: Â Let the program crash, youâ€™ll be motivated to fix the problem quickly. These are typically runtime errors/exceptions/panics.

[top](#Table-Of-Contents)

#### Error Handling - Exceptions vs Errors-as-Values

Errors as values vs exceptions is a hotly debated topic in programming communities:

_**Proponents of errors-as-values:**_

- Fans of errors-as-values argue that function return types that wrap either a success OR failure value is the more reliable approach to error handling because you are explicitly forced to handle errors immediately, typically using a conditional to test for error or success. This ensures error handling is not an afterthought.
- Supporters also argue that there is less uncertainty compared to throwing exceptions because it can be challenging to determine all the exception types that can be thrown by a deep call stack. Also recognise because unhandled unchecked exceptions do not create compilation errors, the compiler can't help you discover all of the different types of unchecked exception that could be thrown, unless you dig and read all the docs.
- Another issue of a specific type of exception known as a 'checked' exception is that they prevent functional composition. This is because the compiler forces you to handle checked exceptions wherever they can be thrown, but they are not considered as part of a function's return signature and type system. Instead, exceptions invoke orthogonal flows that 'break out' of your regular functional flow. Checked exceptions therefore breaks 'referential transparency' (see discussion below on Error Monads such as `Either` & `Validated`). Checked exceptions are generally not recommended these days, except for certain special use-cases where they still have their supporters.

[top](#Table-Of-Contents)

**Proponents of exceptions:**

- Fans of exceptions argue that by forcing you to interleave error checking at function call sites throughout your code obscures the code's happy path and readability.  
- Exception fans also argue that exceptions centralise your error handling code which gives a clean separation of concerns.
- For low-level code, exceptions are largely considered an effective strategy for surfacing underlying issues such as low level operating system issues which may be mistakenly obscured by the errors-as-values pattern (although the same could be said by mindlessly catching all exceptions).
- When used correctly and with discipline, exceptions can also be more performant than pervasive and interleaved error-value checking. This is because languages like C++ and Java have 'zero cost exception handling.' I think this is a misleading term, what it actually means is 'zero cost to the happy path code provided no exceptions are thrown.' Assuming no exceptions are thrown, quite simply, there is less for your code to do as there are no interleaved conditional error checks. While any performance hit from interleaved result checking is likely to be marginal for the majority of use-cases, it may become more pronounced in deeply nested code or tight compute loops. However, this can be mitigated with good code structuring by moving error checks out of and before any performance critical-sections.

A key difference between `try/catch` and `panic/recover` is the resulting control flow following their activation. In a try/catch, unless you re-throw, code coming after the catch/finally block will still execute. This does not happen with panic/recover - a function that is aborted begins to unwind the stack, running deferred blocks/functions as it encounters them (in Go, this is the only place recover takes affect, although use of recover is not widespread in Go and panic is typically used to end the program). Thus, panic/recover is very different to try/catch stemming out of the fact that it is built around deferred logic as a recovery mechanism (e.g. Go & Zig).

[top](#Table-Of-Contents)

Whether to use exceptions has profound implications on your API design and performance, be aware of the issues highlighted above. Some modern languages, e.g. Mojo, go as far as trying to address any choice for you by compiling exception handling code under-the-hood to use errors-as-values. I think the aim is to allow you cleanly separate the happy path from exception handling code (clean separate of concerns) while allowing you to retain the performance of error-as-values should an exception be thrown. At the time of writing, it is too early to tell if this is a successful strategy.

Of course, choice between exceptions or errors-as-values depends on the language and environment - you don't get exceptions support on every architecture and platform. The result pattern is much more flexible especially on embedded systems.

_**Can I use both:**_

- Yes, depending on your language of choice and what is considered idiomatic. Some modern languages support both approaches. For example, to support interoperability with Java, the Kotlin language supports unchecked exceptions as well as its own `Result` type which is intended for low-level code rather than for modelling business errors. For modelling business errors, they recommend using sealed class hierarchies that introduce exhaustive pattern matching to handle errors (see discussion on data oriented programming).

- At the time of writing, a dedicated union type for capturing a result OR one or more errors is on the Kotlin roadmap.

[top](#Table-Of-Contents)

_**Hybrid Approach:**_

- Languages may also support more advanced error handling strategies. For example, the Kotlin Arrow2 library simplifies the use of OOP and Functional error handling within the same code base (Functional vs OOP? - choose both). For example, lower level code or existing code can apply `try/catch/finally` blocks for localised exception handling and recovery if needed, while higher level calling code can provide a wrapping `error context` that can be used at the boundary; Rather than throwing exceptions at the boundary between different layers of code, exceptions can be _raised_ into the higher level error context. Raising rather than (re)throwing this allows the functions that raise to be composed within functional compositional call chains because raising does not break referential transparency. In the top layer of your code, such as in a top-level service facade or global error handler in a webapp, you would then need to handle the exceptions raised within the error context, such as performing a transaction roll back or performing a retry.  For a great presentation with examples, see this great talk from Simon Vergauwen from [Kotlin Conf 2023](https://youtu.be/JcFEI8_af3g?si=vH5OG86JTQWFrGnw) (note that context receivers as used in the talk will be replaced by context parameters in the future).

[top](#Table-Of-Contents)

#### Error Handling - Model Exceptions as Values with Algebraic Data Types 

With ADTs, for any single function, you can replace any thrown exceptions and return values using a single generic abstract data type. Using a sealed interface hierarchy, all possible success and error variations can then be modelled using ad-hoc polymorphism. This means the _abstract_ data type becomes an _algebraic_ data type (ADT), also known as a 'nominal' or  'named' union type (an ADT provides the combination of aggregation *and* choice to model all possible variants). The ADT replaces exceptions with 'errors-as-values,' and multiple optional success types, if required. 

This is super-powerful because you can add new success and/or error/exception return types through ad-hoc polymorphism, and also intentionally restrict all calling clients to a single permissible enum set. This is invaluable for developers of libraries for example where you explicitly want to limit the return types of your library functions and prevent clients overriding with their own implementations.  

[top](#Table-Of-Contents)

To process the function's abstract return type with very little boilerplate, exhaustive pattern matching with switch ensures all possible variants are handled - the compiler will produce an error if any are unhandled. There is a lot to unpack here, but the example given below from Gavin Bierman clearly demonstrates this approach using modern Java (2024). The use of ADTs with pattern matching is being coined in the Java community as 'Data Orientated Programming,' and can be applied for modelling any data type hierarchies such as converting JSON to Java types, but Java certainly wasn't the first language to implement this approach. I suspect that this approach will become very popular in the Java community in the future, moving away from exceptions in higher level application code (note, as discussed above, exceptions will still have their place in lower level library and framework code). 

![](attachments/Pasted%20image%2020241103122918.png)

Using ADTs to model better return types. After Gavin Bierman's Devoxx talk, Java Language Futures: https://www.youtube.com/watch?v=NNPN5tvjzqA&t=2651s

[top](#Table-Of-Contents)


#### Error Handling - Exceptions should not be used for flow control - exceptional does not mean conditional

Passing around a deeply nested stack trace within conditional and control logic is very expensive, don't do it. Instead, model your (known) business errors as values (no need to pass around exceptions), and leave exceptions for coding errors and exceptional situations. If you want control flow logic that says "if success do this..., but if an error occurs then do this..." then use the result pattern.

[top](#Table-Of-Contents)

#### Error Handling - Only use exceptions for exceptional situations such as coding errors and unexpected errors - exceptional does not mean conditional

For example, an invalid object posted to your API is not exceptional, this should be handled as a potential business error. In the situation where some code throws an exception such as a parse error, catch it locally, extract the useful information, and return an error-value. In general, the result-as-value pattern is appropriate where the problem is the fault of the caller and not a programming mistake e.g., invalid input / form data.

[top](#Table-Of-Contents)

#### Error Handling - Provide relevant exceptions for the abstraction layer

If you use exceptions (not all languages have exceptions e.g., Rust, Go), define Exceptions in terms of a callerâ€™s needs and wrap 3rd party library APIs including their exceptions. Often, only a few custom exception classes are needed for a particular area of code.

[top](#Table-Of-Contents)

#### Error Handling - Bubble exceptions upwards or trap at source

Generally, pushing exception handling code up to the â€˜outer layersâ€™ of your code toward the boundaries is usually a good approach. It also helps cleanly separate the â€˜happy pathâ€™ from interleaving error handling code.Â  However, this isnâ€™t a hard rule, in some situations you may need to try/catch/finally at the source of the error to take important corrective actions such as closing an IO resource or rolling-back a DB transaction.

[top](#Table-Of-Contents)

#### Error Handling â€“ Model the absence of value explicitly

This largely depends on the language you are using:

- Nullable languages (C/C++/Java): Dereferencing a null pointer causes bad things to happen. This is known as â€˜the billion-dollar mistakeâ€™ coined by Tony Hoare, in 1965. Â In your code, be sure to make it clear when null is meant to represent the â€˜absence of valueâ€™ (e.g., with @Nullable annotations for example). If you must, when using a 3rd party library for example, be â€˜defensiveâ€™ such as checking for nulls using if statements where appropriate.

- Side Note: polluting your code with defensive checks is often considered dirty, but sometimes you just have to it if no other approach is available.

- Side Note: many argue null is an acceptable way to represent the absence of value, itâ€™s just a fact and is too fundamental in many layers. Â They argue the real billion-dollar mistake is not null itself, but in the failure of the language to do type-safe handling of null.

- Some languages e.g., Kotlin, Rust & Python have â€˜safe nullabilityâ€™ baked into their type-systems e.g., None to mean no value and optional â€˜?â€™ on variables (â€˜var?â€™) to indicate this variable might be null.

- Functional languages commonly use â€˜Eitherâ€™ monads to wrap errors and the absence of value. With this pattern, the programmer is forced to handle the occurrence of no value, it canâ€™t be ignored, mistakenly or otherwise, as with defensive programming. See below.

- Various modern languages use Algebraic Data Types (an extension of the â€˜Special Caseâ€™ pattern) and return types that wrap either a successful result or an error/null (Go, Rust, Kotlin, modern Java):

Â·Â Â Â Â Â Â  [https://martinfowler.com/eaaCatalog/specialCase.html](https://martinfowler.com/eaaCatalog/specialCase.html)

- ADTs include â€˜Sum Typesâ€™ or â€˜Product Typesâ€™ and are excellent for representing multiple special cases, including multiple error states.

[top](#Table-Of-Contents)

#### Error Handling in Functional Programming â€“ error monads such as Either and Validated

In functional languages monads are widely used to chain a sequence of function calls into a clean â€˜happy pathâ€™. This is also known as â€˜functional compositionâ€™. A core tenant of functional approaches is to produce more declarative and expressive code over classical imperative approaches which usually interleave error handling with the happy path. In functional approaches, you define â€˜what to doâ€™ with functions, not â€˜how to do itâ€™ as with imperative approaches.

An `Either` monad wraps either a result type or an error type, but not both, typically (`Either<LeftError, RightSuccess>`). Note that Rust is opposite, where left is success and right is error. An instance of a monad is passed between functions in a call chain. Wrapping errors within the â€˜monadic contextâ€™ allows the functional call chain to be composed without polluting and breaking the chain with exceptions and error handling code. Â If a function returns a LeftError wrapped in the Either, subsequent functions in the chain will short-circuit and will simply return the erroneous Either. This continues until the end of the call chain is reached.

A `Validated` monad aggregates errors or exceptions within a functional call chain. The purpose is to capture all the errors rather than short-circuiting on the first. A simple example would be capturing all the errors on a form, rather than returning early on the first erroneous form entry.

Regarding exceptions in functional composition: If your language uses â€˜Checked Exceptionsâ€™ (e.g., Java or when using other JVM languages that call out to underlying Java libs), you canâ€™t throw checked exceptions during functional composition as they force you to handle the error and break the call chain with try/catch or throws statements. In this scenario, wrap the exception in the monadic context and return a LeftError. Note that throwing _unchecked_ exceptions is ok in a functional call chain as they donâ€™t pollute the happy path with try/catch or throws, but you likely still want to wrap the error in the monadic context to return an error-as-value, e.g. if that error is not a programming error or is an exceptional circumstance.

[top](#Table-Of-Contents)

### Data Orientated Programming with Algebraic Data Types - ADTs

The Special Case Pattern is one example for modelling your domain types in such a way that the absence of value is explicitly modelled in your domain making illegal program states and crashes more unlikely. However, you can go a lot further using Algebraic Data Types (ADTs). ADTs combine â€˜Product Typesâ€™ for modelling aggregation such as a C/Golang/Rust â€˜structsâ€™ or Java's Record type with â€˜Sum Typesâ€™ for modelling choice, also known as â€˜Union Typesâ€™ or â€˜Tagged Unionsâ€™. This simple combination of aggregation and choice is deceptively powerful and shows up in many programming languages to model domains, return types and function arguments:

- Product Types are great for modelling aggregation, and include immutable data classes such as records, data objects, and structs. They are called â€˜Product Typesâ€™ because their state â€˜when considered as a wholeâ€™ is the cartesian product of their data.

- Sum Types can be used to represent choice and are polymorphic - an abstraction such as a marker/type interface with a fixed set of implementing subtypes (e.g., â€˜sealedâ€™ classes or interfaces in Kotlin/Java, â€˜enumâ€™ in Rust, â€˜Unionâ€™ types in Python). They are called Sum Types because the set of possible types is the sum (union) of the total allowable set.

[top](#Table-Of-Contents)

In some modern languages (e.g Rust, modern Java, and others), ADTs can be efficiently processed using de-structuring and exhaustive pattern matching with `when` & `switch` statements. Exhaustive matching means the compiler will generate a compilation error if not all types are explicitly handled. As highlighted by Gavin Bierman in his Devoxx talk, you can spot many 'lightly disguised abstractions such as JSON' and model them as ADTs as shown in the following diagram: 

![](attachments/Pasted%20image%2020241103131635.png)

From Gavin Bierman's Devoxx talk, Java Language Futures: https://www.youtube.com/watch?v=NNPN5tvjzqA&t  Using the sealed interface, it would be simple to permit a range of additional custom types that implement `JsonValue` such as `MyCustomString` and `ThingArray` for example.  

[top](#Table-Of-Contents)

### Concurrency and Parallelism

In computing, concurrency is not parallelism, despite the two terms having very similar dictionary definitions. *Concurrency is a software concern* involving context switching of a process on a single CPU core via a â€˜kernel threadâ€™ (these types of thread are also commonly referred to as process thread, carrier thread, and platform thread) . Context switching gives the illusion that multiple things are happening at once because the time slicing is so small. *True parallelism is both a software and hardware concern* which requires increasingly more hardware to do more things at once. This can range from multiple cores on one CPU, multiple CPUs, multiple nodes, remote actors, remote VMs, cloud functions such as Lambda and more. 

For example, parallelism with increasingly 'heavyweight' hardware implementations could range from:
- single host with shared memory parallelism using platform threads that map to multiple cores/CPUs on the same motherboard, 
- as above but data is shared within the same process using other mechanisms than memory, such as a memory-mapped file (memory and disk) or other inter-process-communication methods (IPC), 
- multi-processing where each child-process has its own memory space and each processes cosumes one core, 
- K8s worker nodes working within the same K8s cluster but typically without a high performance interconnect,
- HPC using compute clusters that message-pass over a 'tightly coupled' high perfomance interconnect, 
- geograpically distributed nodes (e.g., remote Actors / FaaS / Grid computing), 
- geograpically distributed multi-clustering (e.g., Grid, federated HPC, a potential route to exa-scale). 

Some general recommendations:
- Keep platform threads as isolated as possible & limit mutable global state:
    - Sharing of fixed immutable state is fine. 	
    - Taking defensive copies of data can help prevent race conditions and other concurrency related â€˜spooky actions at a distanceâ€™.
    - Try to be more functional and limit your use of global mutable state.
    - Understand the pitfalls of multi-threaded code such as race-conditions, ghost reads, dirty reads, dirty writes, and deadlock. Â 

- Keep synchronised critical sections as small as possible:
     - Amdahlâ€™s law: "The overall performance improvement gained by optimising (i.e. parallelising) a single p art of a system is limited by the fraction of time that the improved part is actually used," or more simply: even a small amount of synchronization *_significantly*_ affects performance. 
     - Here are some examples of Amdahl's law:  
         - If 95% of the time spent by your code is parallel, throwing more processors at the problem doesnâ€™t improve speedup beyond ~256 processors. 
         - If the amount of time spent by your code is <50% parallel, adding more processors won't speedup your code at all.
         - If the amount of time spent by your code is ~95% parallel, the maximum speedup is only 20 times and this takes 2048 processors. 

![](attachments/Pasted%20image%2020240611095042.png)

[top](#Table-Of-Contents)

- Understand the pitfalls of multi-threaded programming. If deadlock, live lock, ghost-reads, dirty reads, and atomic vs composite actions donâ€™t make much sense to you (do you think â€˜i++â€™ is atomic? â€“ no it is not), then you will no doubt run in to problems. These days, there is often a much better approach to coding low-level multi-threaded and shared memory models.
-  When testing, use more threads than processors â€“ running with more threads than processor cores encourages task swapping. The more frequently your tasks swap, the more likely you will find issues.

[top](#Table-Of-Contents)

#### Know the difference between IO bound tasks and CPU bound tasks and their common solution patterns

- *IO Bound Tasks* require asynchronous patterns to achieve concurrency. The solution patterns include:

 	- **Async/Await and Coroutines** (e.g., Goâ€™s â€˜Goroutinesâ€™ and Kotlinâ€™s suspending functions). These are often referred to as â€˜coloured approachesâ€™ because your functions are typically split into two types; 1) red functions for asynchronous code typically requiring special keyword modifiers to annotate functions and their call-sites e.g. `async` (function) and `await` (call-site) and; 2) blue functions for plain synchronous code having no modifiers. Note, it could be argued that Go's Goroutines are not coloured because they only require the `go` keyword at the function call-site, there is no need to annotate a function as asynchronous which allows you to call regular functions in an asynchronous way (although you frequently need to pass in concurrency primitives to share data such as `Channels`).  Here is the original and now famous blog: [https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function)
 	- **Virtual-Threads / Fibres** such as the â€˜colourlessâ€™ Project Loom for the JDK where the virtual threads are implemented in user space using continuations: [https://wiki.openjdk.org/display/loom/Main](https://wiki.openjdk.org/display/loom/Main). With the release of Loom, the venerable JVM platform arguably boasts the most advanced approach to concurrency. JVM languages can implement a truly colourless programming approach on top using a combination of platform and virtual threads and higher-level abstractions such as the streams API. 
 	- **Continuations** are very low-level and are used to implement patterns such as coroutines & virtual threads. Continuations can be suspended, stored on the heap, and restarted. Typically, you would not directly use continuation APIs using a Continuation Passing Style (CPS) in your own application logic, although some languages do have public APIs for CPS.
 	- **Async-Wrapper types such as Futures & Promises.** Note that these are really just higher-level synchronisation primitives, and the task that you await itself would need to be non-blocking to achieve high levels of concurrency. Â 
 	- **Call-Back functions** (beware â€˜call-back hellâ€™ as often seen in JavaScript). In fact, more friendly â€˜synchronousâ€™ patterns such as Coroutines and Continuations simply abstract much of the lower-level call backs from the programmer.
 	- **Non-blocking IO primitives** where libs & APIs are non-blocking instead of blocking.
 	- **Reactive Frameworks** e.g., project Reactor. Performant, but typically requiring a horrible API that has a lot of 'hidden magic.' In the JDK space, with the delivery of Project Loom (see above), I believe reactive approaches will decrease in popularity.

[top](#Table-Of-Contents)

-  *CPU Bound Tasks* have different solution patterns:

 	- **Platform/OS/POSIX/Kernel threads (pthreads).** These are good for numerical computations that do not require much, preferably no, IO. An example would be a â€˜tight computational loopâ€™ that performs an in-memory calculation that has no side-effects.  Note that platform threads are rather heavyweight and so should be pooled for effective resource usage (see Fork-Join-Pools). For example, on Linux, each thread typically requires ~1MB of memory per thread â€“ this is because they are controlled by the operating system, and the OS has to be generic enough to handle a variety of use-cases, so 1MB was assumed to be a catch-all default. Platform threads are _very_ different from Virtual Threads in terms of how they are implemented. Â A platform thread is very similar to a process in terms of resource-cost, except that threads allows memory sharing between multiple threads while multiple processes do not share the same memory space. For multiple processes, you need some other mechanism to share state and messages between processes, such as a common memory-mapped file(s), file system, databases, and message brokers.
 	- **Shared memory frameworks** such as OpenMP which make multi-threaded programming simpler by avoiding low-level synchronisation primitives. Â 
 	- **Fork-Join-Pools and related â€˜Work Stealingâ€™** patterns that involve task queues. FJP is a highly recommended way to achieve best possible performance because low-level Kernel/OS threads are re-used to maximum effect.
 	- **Horizontal scaling with Pub-Sub and Competing Consumers.** This is where multiple compute nodes subscribe to a message channel and pull messages from the channel. If the queue-depth gets too high, you add more consumers to process the messages.
 	- **Lazy Parallel Streams** in functional approaches. Functional streams are typically executed lazily, importantly after the whole computation has been fully defined. This allows the caller or runtime to perform optimisations such as automatic parallelisation. This can only be achieved because the full stream is defined lazily, ahead of time.    
 	- **Message Passing** e.g., the Actor model (e.g., Akka) & Message Passing Interface (e.g., OpenMPI) in HPC are both examples of message passing. Note that the Actor model is actually the canonical parallelism pattern, while MPI is quite niche (largely just the HPC community).
- If you must use low-level locks and synchronization primitives with critical sections, try to use â€˜re-entrantâ€™ locks for better composability and performance over non-re-entrant synchronized blocks. Check if the languages mutexes (semaphores, count-down latches) are re-entrant (language agnostic advice).

[top](#Table-Of-Contents)

### Security Development Practices

- For Hartree folks, if using a cloud hosted development environment, you must consult and agree to the practices given in [Hartreeâ€™s Cloud Acceptable Use Policy](https://stfc365.sharepoint.com/:w:/r/sites/HartreeIGaA/ISO27001/Information%20Security%20Management%20System/Policies/HCIS-0044-plc-01.1-Cloud%20Access.docx?d=wc3116a720ba941cc9de27c0029df1932&csf=1&web=1&e=zkvG1Q) document. All polices and related information can be found [here](https://stfc365.sharepoint.com/sites/HartreeIGaA/ISO27001/Forms/AllItems.aspx?csf=1&web=1&e=ZWjlia&siteid=%7B938CBF09%2D9359%2D4BB6%2DB56D%2D55D938C510C1%7D&webid=%7B02B09618%2D9B45%2D479E%2DBFA4%2D9DEE7B833CA6%7D&uniqueid=%7B8BE63CF1%2DD73D%2D441D%2D9570%2DCD95D488D38A%7D&RootFolder=%2Fsites%2FHartreeIGaA%2FISO27001%2FInformation%20Security%20Management%20System&FolderCTID=0x012000AFB03BC45914F7439215AF3907065BF0).

![](attachments/Pasted%20image%2020240611100053.png)

[top](#Table-Of-Contents)

- Never add plain-text credentials including username/passwords and ssh keys/tokens into version control.
- Sensitive data such as credentials can be stored locally in your local dev environment using ephemeral sources such as environment variables, command line arguments, local files such as '.env' files that are git ignored (use a '.gitignore' file) to ensure they are not committed to VCS, and local key-chains / credential stores such as HashiCorp's vault and [https://github.com/openbao/openbao](https://github.com/openbao/openbao) .
- Do not hard-code secrets in code. For production, use well-established secret serving methods such as creating a secret object in OpenShift that configures environment variables for your running pods.Â Â 
- Public URLs should always be secured using TLS/HTTPS. Host certificates can be freely obtained from [https://letsencrypt.org](https://letsencrypt.org) Â 
- Always consider linting and scanning your code for vulnerabilities and anti-patterns using well-established tooling such as FindBugs, Snyk for containers, OWASP's Dependency Check tool suite: [https://owasp.org/www-project-dependency-check](https://owasp.org/www-project-dependency-check) Â 
- Familiarise yourself with OWASP's Top Ten security risks for webapps: [https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten) Â 
- Always update default passwords that are shipped with products e.g., 'admin' is sometimes used default username and password pair.
- To minimize injection attack surface, donâ€™t use your own variable binding or hardcode parameters using string concatenation â€“ use the supported variable binding tooling to ensure values are always escaped.

[top](#Table-Of-Contents)

## Agile Process Guide aka Feedback Driven Development

For the Hartree Centre, we propose an Agile methodology as it largely suits the type of projects we do. Agile is an overused term, so for Hartreeâ€™s purposes, a good definition is â€˜Feedback Driven Developmentâ€™.Â  Iteration and customer feedback really ARE essential if we are to successfully address real customer needs. Know that industry data shows that even for the best software companies in the world, two thirds of their ideas produce zero or negative value so continuous feedback is essential to mitigate the risks: Online Controlled Experiments at Large Scale: [http://ai.stanford.edu/~ronnyk/2013%20controlledExperimentsAtScale.pdf](http://ai.stanford.edu/~ronnyk/2013%20controlledExperimentsAtScale.pdf)

[top](#Table-Of-Contents)

According to the values of the original Agile manifesto (search the original â€˜Snowbird meetingâ€™), agile development practices include risk-taking, rapid-feedback, frequent and high-bandwidth communications across the whole team, and collective project ownership. This means full stakeholder involvement with everyone: developers, testers, scientists, end-users, and business-development managers. It emphasises â€˜individuals and interactions over processes and tools.â€™ Agile is especially relevant for greenfield and relatively short-lived projects which describe many of the projects we do at the Centre.

[top](#Table-Of-Contents)

We recommend weekly or fortnightly iterations involving customer playbacks and demos. Anything longer than 2 weeks can require significant course correct if/when you go in the wrong direction - agile aims to catch problems early and to course correct.Â  According to Uncle Bob Martin, the emergence of agile was to â€œfind out how screwed we were as early as possible, it wasnâ€™t just about writing software quicklyâ€.

[top](#Table-Of-Contents)

### Design Thinking Workshops and Scoping Document

Design Thinking puts you in the shoes of the customer so that you can understand their pain points. This helps design solutions that really address customer needs. Hartree have a set of recipes for activities that you can use to conduct [DT workshops](https://stfc365.sharepoint.com/:f:/r/sites/TheHartreeCentreCommunityChannel/Shared%20Documents/Hartree%20Communications/Business%20Development/Design%20Thinking%20Workshops?csf=1&web=1&e=cpdeqS). The activities donâ€™t have to be applied religiously and you can adapt as needed. The activities include As Is Scenario Journey Map, Empathy Maps, User Persona and Problem Statements, User Stories, Ideation, Prioritisation, Ideal To-Be Scenario Journey Map, Outcome Statements, Cupcake Roadmaps.

Hartree also has a [scoping doc](https://stfc365.sharepoint.com/:f:/r/sites/TheHartreeCentreCommunityChannel/Shared%20Documents/Hartree%20Communications/Business%20Development/Design%20Thinking%20Workshops?csf=1&web=1&e=cpdeqS) that you can send the customer ahead of time to help focus minds.

[top](#Table-Of-Contents)

### Epics and Work Package Span Multiple Sprints

Epics are like Work Packages. Typically, they require multiple tasks and span multiple sprints.

### Define user stories with the INVEST Framework or Who-What-Why or the Connextra Card Template â€“ all are good and you do not need to be too rigid

- _â€œAs userType [X], I need a way to do [what?] so that I can [whatâ€™s the benefit]â€._

- _Who, What Why_

- INVEST:
 	- Independent - this means we try to design stories that do not need to be implemented in a particular order (a soft rule as there may well be stories that need to be prioritised).
 	- Negotiable - to retain agility, we recognise that requirements often/inevitably evolve and so we don't focus overtly on getting the details right up-front (i.e., Waterfall).
 	- Valuable - must have a clear and quantifiable benefit to the client.
 	- Estimable - a story must be concrete enough that developers can estimate it.
 	- Small - a story must not be larger than one or two developers can implement in a single iteration.
 	- Testable - when a developer says that its 90% ready, nobody really knows how close it is to being finished.
  
[top](#Table-Of-Contents)

### Arrange core user stories into a Journey Map with a narrative flow or backbone of Big Activities moving from left to right

Beneath each big activity, define short verb phrases to describe what the user does to achieve each big activity.

![](attachments/Pasted%20image%2020240611100610.png)

[top](#Table-Of-Contents)

### Task Backlog

Create a list of tasks and use â€˜planning pokerâ€™ / finger-waving to estimate effort â€“ after a â€˜3, 2, 1â€™ countdown, everyone at the same time provides an estimate of the difficulty of a task between 1 and 5 or holds up a card. This ensures honest estimates from everybody which is Important because different team members may have different experiences/specialities of the task area. See [https://www.evernote.com/l/AWQ6FGRtfrNI1az21FVp9aosQ9zu8b-4CXg](https://www.evernote.com/l/AWQ6FGRtfrNI1az21FVp9aosQ9zu8b-4CXg)

### Requirements Document and System Architecture Document

### 1 to 2-week Sprints Â 

Break up the Backlog into sprints to deliver your cup-cake roadmap. Provide effort estimations for tasks using â€˜planning pokerâ€™. More than two weeks generally gives enough time for software to deviate without requiring significant refactoring and course-correction, so we donâ€™t recommend more than 2 weeks.

[top](#Table-Of-Contents)

### Inline Testing

Test the critical path and be pragmatic about coverage - 80% coverage often not feasible or even useful. Develop tests in-line with the mainline branch. TDD helps us think about the public interfaces / API to the code under development.

### Demo and Playbacks

At the end of the sprint, demo your progress to the client. This is important. Agile can be paraphrased as â€˜Feedback Driven Developmentâ€™.Â  It is essential to get that customer feedback early and continuously.

[top](#Table-Of-Contents)

### Acceptance with Sign Off and Cucumbers

- If possible, get the client to sign-off work every month (PMO have a â€˜Decision Point Reviewâ€™ template).
- Use the Cucumber approach for acceptance testing i.e., â€˜Given, When, Thenâ€™.Â  For example: â€˜Given [a particular context/scenario], When [something happens], Then [this is the result]â€™.

### Iteration and Incrementalism

- Recognise that we need both iterative & incremental approaches to building complex systems. Incrementalism == modularity, which helps break down complexity.
- Review the Backlog, revise and plan your next sprint, jump to 7.

![](attachments/Pasted%20image%2020240611100815.png)

[top](#Table-Of-Contents)

### Cup Cake Road Maps

- Plan a cup-cake dev roadmap. A cup-cake wonâ€™t feed everyone, but it can have core ingredients - itâ€™s a whole-product that a user can taste sooner rather than later.
- If the cup-cake tastes good, proceed with the vanilla sponge, hopefully ending with the multi-tier wedding cake that can feed everyone. Iterate your development roadmap and keep soliciting user feedback.

Thanks for reading, comments/feedback most welcome. Have fun !

[top](#Table-Of-Contents)

## Appendix Recommended Texts

![](attachments/Pasted%20image%2020240611100930.png)

![](attachments/Pasted%20image%2020240611100944.png)

[top](#Table-Of-Contents)

---
