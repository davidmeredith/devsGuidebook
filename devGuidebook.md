# Dave's Dev Guidebook

Hi there. This is my attempt at writing a developer guidebook 📖. I originally did this for the STFC Hartree Centre but now I maintain an updated version here. Feel free to raise issues if you disagree with anything, its just my opinion which is subject to change - I believe that strong opinions should be loosely held. There is nothing truly original here, but what I do hope to add is a balanced and informed opinion based on many years hard won experience. Many of the published practices out there I agree with and have personally encountered or applied on projects, others I'm not so sure about. Happy reading. DaveM

Last Updated 03/02/25.  Enjoy.

## Table Of Contents

```dataviewjs
dv.view('toc')
```
[//]: # (To update the manual contents table between the '--start/endContents' markers, copy the autogenerated toc within Obsidian and paste the updated text within the markers. Then select the text and use the following global line substitutions to update all the links in the toc to be GitHub compatible. To paste into command mode use 'Ctrl-R regId': 
'<,'>s/%20/-/g
'<,'>s/app:\/\/obsidian\.md\/devGuidebook\.md//g
)

--startContents
1. [Table Of Contents](#Table-Of-Contents)
2. [Why Software Dev Guidebook](#Why-Software-Dev-Guidebook)
    1. [Target Audience](#Target-Audience)
3. [High Level Recommendations](#High-Level-Recommendations)
    1. [If it is not in Git it does not exist](#If-it-is-not-in-Git-it-does-not-exist)
        1. [Feature Branching vs Trunk Based development](#Feature-Branching-vs-Trunk-Based-development)
        2. [Integrating Upstream Changes](#Integrating-Upstream-Changes)
        3. [Rebase vs Merge](#Rebase-vs-Merge)
    2. [Adopt Semantic Versioning for tags and releases](#Adopt-Semantic-Versioning-for-tags-and-releases)
    3. [Review each others code and be supportive](#Review-each-others-code-and-be-supportive)
    4. [If the critical path has not been reviewed it should not go onto master branch](#If-the-critical-path-has-not-been-reviewed-it-should-not-go-onto-master-branch)
    5. [Continuous Integration - If it does not have tests it does not work](#Continuous-Integration---If-it-does-not-have-tests-it-does-not-work)
    6. [Continuous Delivery](#Continuous-Delivery)
    7. [Continuous Deployment](#Continuous-Deployment)
    8. [If it Does not have Documentation it is Not Usable](#If-it-Does-not-have-Documentation-it-is-Not-Usable)
    9. [Learning mindset](#Learning-mindset)
    10. [Customer Bill of Rights - modified from Uncle Bob Martin Clean Agile](#Customer-Bill-of-Rights---modified-from-Uncle-Bob-Martin-Clean-Agile)
    11. [Developer Bill of Rights - modified from Uncle Bob Martin Clean Agile](#Developer-Bill-of-Rights---modified-from-Uncle-Bob-Martin-Clean-Agile)
    12. [Tooling](#Tooling)
        1. [Do not be Smart - Use the Right Tools for the Job and for your customer](#Do-not-be-Smart---Use-the-Right-Tools-for-the-Job-and-for-your-customer)
            1. [To Garbage Collect or Not To GC](#To-Garbage-Collect-or-Not-To-GC)
            2. [Monads and Green Threads need a GC](#Monads-and-Green-Threads-need-a-GC)
            3. [What about Rust or Zig](#What-about-Rust-or-Zig)
        2. [Kanban - Jira and Confluence](#Kanban---Jira-and-Confluence)
        3. [Gitlab and Version Control](#Gitlab-and-Version-Control)
        4. [Container Repository](#Container-Repository)
        5. [Build Tools](#Build-Tools)
        6. [Static Code Analysis](#Static-Code-Analysis)
        7. [Containerisation for Portability](#Containerisation-for-Portability)
        8. [Workflows and Containerisation](#Workflows-and-Containerisation)
4. [Coding Recommendations and Best Practices](#Coding-Recommendations-and-Best-Practices)
    1. [High Quality Code is Easy to Understand and Change](#High-Quality-Code-is-Easy-to-Understand-and-Change)
    2. [Quality is the best shortcut - Fowler Design Stamina Hypothesis](#Quality-is-the-best-shortcut---Fowler-Design-Stamina-Hypothesis)
    3. [Meaningful and Descriptive Names](#Meaningful-and-Descriptive-Names)
        1. [Use Intention Revealing Names](#Use-Intention-Revealing-Names)
        2. [Considered Comments](#Considered-Comments)
        3. [Do Not Name Abstractions After Constituent Parts](#Do-Not-Name-Abstractions-After-Constituent-Parts)
    4. [Testing has Three Main Purposes](#Testing-has-Three-Main-Purposes)
    5. [Keep Classes and Functions Smallish](#Keep-Classes-and-Functions-Smallish)
    6. [Limit the Number of Function Arguments](#Limit-the-Number-of-Function-Arguments)
    7. [Separation of Concerns for Locality of Behaviour](#Separation-of-Concerns-for-Locality-of-Behaviour)
    8. [Code Should be Cohesive](#Code-Should-be-Cohesive)
    9. [OOP Redefined](#OOP-Redefined)
    10. [SOLID](#SOLID)
        1. [SRP](#SRP)
        2. [Open-Closed Principle](#Open-Closed-Principle)
    11. [Pervasive Polymorphism](#Pervasive-Polymorphism)
        1. [Inheritance is Solely for Strong 'Is A' Type Relationships to Maintain State Invariants and Post-Conditions](#Inheritance-is-Solely-for-Strong-'Is-A'-Type-Relationships-to-Maintain-State-Invariants-and-Post-Conditions)
        2. [Inheritance Should be Explicitly Designed For](#Inheritance-Should-be-Explicitly-Designed-For)
        3. [Avoid Paying too much Inheritance Tax - Use Parametric Polymorphism to Augment your Type-System With Shared Marker Types](#Avoid-Paying-too-much-Inheritance-Tax---Use-Parametric-Polymorphism-to-Augment-your-Type-System-With-Shared-Marker-Types)
        4. [Parametric Polymorphism for Existing Types](#Parametric-Polymorphism-for-Existing-Types)
        5. [Extensions for Augmenting Existing Types](#Extensions-for-Augmenting-Existing-Types)
        6. [Structural Polymorphism and Duck Typing](#Structural-Polymorphism-and-Duck-Typing)
        7. [Sealing](#Sealing)
        8. [Composition / Delegation](#Composition-/-Delegation)
    12. [Parametric Polymorphism Language Comparison](#Parametric-Polymorphism-Language-Comparison)  
        1. [Rust Example](#Rust-Example)  
        1. [Kotlin Example](#Kotlin-Example)  
        1. [Java Example](#Java-Example)  
        1. [Go Example](#Go-Example)
    13. [Data Orientated Programming vs OOP - Choose Two](#Data-Orientated-Programming-vs-OOP---Choose-Two)
    14. [Dependency Rule and Dependency Inversion Principle](#Dependency-Rule-and-Dependency-Inversion-Principle)
        1. [A Hearts and Minds Analogy](#A-Hearts-and-Minds-Analogy)
    15. [Dependency Injection and Inversion of Control to Implement the Dependency Rule and DI](#Dependency-Injection-and-Inversion-of-Control-to-Implement-the-Dependency-Rule-and-DI)
    16. [Circular Dependencies via Setters and Lazy Initialisation](#Circular-Dependencies-via-Setters-and-Lazy-Initialisation)
    17. [Dynamic Late Binding vs Static Binding](#Dynamic-Late-Binding-vs-Static-Binding)
    18. [It Should Not be Possible to Create an Object in an Invalid State](#It-Should-Not-be-Possible-to-Create-an-Object-in-an-Invalid-State)
        1. [Throwing Exceptions from Constructors](#Throwing-Exceptions-from-Constructors)
        2. [Use a Smart Constructor or Factory to Return a Smarter Return Type](#Use-a-Smart-Constructor-or-Factory-to-Return-a-Smarter-Return-Type)
        3. [Use the Builder Pattern to Check Complex Invariants Before Building the Object](#Use-the-Builder-Pattern-to-Check-Complex-Invariants-Before-Building-the-Object)
    19. [Know Some Design Patterns](#Know-Some-Design-Patterns)
        1. [The Strategy Pattern Example](#The-Strategy-Pattern-Example)
        2. [The Visitor Pattern](#The-Visitor-Pattern)
        3. [Builder Pattern for More Complex Object Creation Scenarios](#Builder-Pattern-for-More-Complex-Object-Creation-Scenarios)
    20. [Information Hiding](#Information-Hiding)
    21. [Keep it Simple Stupid KISS](#Keep-it-Simple-Stupid-KISS)
    22. [DRY Do not Repeat Yourself](#DRY-Do-not-Repeat-Yourself)
    23. [YAGNI You Are not Going to Need It](#YAGNI-You-Are-not-Going-to-Need-It)
    24. [Comment in line As You Go](#Comment-in-line-As-You-Go)
    25. [The Boy Scout Rule](#The-Boy-Scout-Rule)
    26. [Principal of Least Knowledge and Train Wrecks - The Law of Demeter](#Principal-of-Least-Knowledge-and-Train-Wrecks---The-Law-of-Demeter)
    27. [FP vs OOP - Choose Two](#FP-vs-OOP---Choose-Two)
        1. [Be Careful Not to Pollute Pure Functions with Hidden Mutable State](#Be-Careful-Not-to-Pollute-Pure-Functions-with-Hidden-Mutable-State)
        2. [Make Private your Default Class Level Visibility](#Make-Private-your-Default-Class-Level-Visibility)
        3. [Make Immutability your Default](#Make-Immutability-your-Default)
        4. [Interior Mutability](#Interior-Mutability)
        5. [Use Calculations Where Possible to Limit Side Effects](#Use-Calculations-Where-Possible-to-Limit-Side-Effects)
        6. [Separate Operations from Calculations](#Separate-Operations-from-Calculations)
    28. [Data Orientated Programming with Algebraic Data Types - ADTs](#Data-Orientated-Programming-with-Algebraic-Data-Types---ADTs)
    29. [Error Handling](#Error-Handling)
        1. [Error Handling - Four Types of Problems](#Error-Handling---Four-Types-of-Problems)
        2. [Error Handling - Fail Early](#Error-Handling---Fail-Early)
        3. [Error Handling - Be defensive at application boundaries, not within your inner domain logic](#Error-Handling---Be-defensive-at-application-boundaries,-not-within-your-inner-domain-logic)
        4. [Error Handling - Model the Absence of Values Explicitly](#Error-Handling---Model-the-Absence-of-Values-Explicitly)
            1. [Error Handling - Do Not Initialise with Null or Return Null](#Error-Handling---Do-Not-Initialise-with-Null-or-Return-Null)
        5. [Error Handling - Exceptions vs Errors-as-Values](#Error-Handling---Exceptions-vs-Errors-as-Values)
            1. [Proponents of errors-as-values](#Proponents-of-errors-as-values)
            2. [Proponents of exceptions](#Proponents-of-exceptions)
            3. [Can I use both styles in a hybrid approach](#Can-I-use-both-styles-in-a-hybrid-approach)
        6. [Error Handling - Exceptions Should Not be Used for Flow Control - Exceptional Does Not Mean Conditional](#Error-Handling---Exceptions-Should-Not-be-Used-for-Flow-Control---Exceptional-Does-Not-Mean-Conditional)
        7. [Error Handling - Only use Exceptions for Exceptional Situations Such As Coding Errors and Unexpected Errors](#Error-Handling---Only-use-Exceptions-for-Exceptional-Situations-Such-As-Coding-Errors-and-Unexpected-Errors)
        8. [Error Handling - Provide Relevant Exceptions for the Abstraction Layer](#Error-Handling---Provide-Relevant-Exceptions-for-the-Abstraction-Layer)
        9. [Error Handling - Bubble Exceptions Upwards or Trap at Source](#Error-Handling---Bubble-Exceptions-Upwards-or-Trap-at-Source)
        10. [Error Handling - Model Exceptions as Values with Algebraic Data Types](#Error-Handling---Model-Exceptions-as-Values-with-Algebraic-Data-Types)
        11. [Error Handling in the Functional Way - Returning Smarter Wrapper Types eg the Either Monad](#Error-Handling-in-the-Functional-Way---Returning-Smarter-Wrapper-Types-eg-the-Either-Monad)
            1. [What are Monads aka Higher-Kinded Types](#What-are-Monads-aka-Higher-Kinded-Types)
            2. [Basic Monad implementation](#Basic-Monad-implementation)
            3. [Example Type Safe Functional Composition by Short-Circuiting on Errors](#Example-Type-Safe-Functional-Composition-by-Short-Circuiting-on-Errors)
            4. [Can I Combine Monads and ADTs to Model Multiple Success or Error states](#Can-I-Combine-Monads-and-ADTs-to-Model-Multiple-Success-or-Error-states)
            5. [Other Error Monads such as Validation and Ior](#Other-Error-Monads-such-as-Validation-and-Ior)
            6. [Inlining within a Computation Block to Avoid Nesting](#Inlining-within-a-Computation-Block-to-Avoid-Nesting)
    30. [Effect Orientated Programming](#Effect-Orientated-Programming)
    31. [Concurrency and Parallelism](#Concurrency-and-Parallelism)
        1. [Know the difference between IO bound tasks and CPU bound tasks and their solution patterns](#Know-the-difference-between-IO-bound-tasks-and-CPU-bound-tasks-and-their-solution-patterns)
    32. [Security Development Practices](#Security-Development-Practices)
5. [Agile Process Guide aka Feedback Driven Development](#Agile-Process-Guide-aka-Feedback-Driven-Development)
    1. [Design Thinking Workshops and Scoping Document](#Design-Thinking-Workshops-and-Scoping-Document)
    2. [Epics and Work Package Span Multiple Sprints](#Epics-and-Work-Package-Span-Multiple-Sprints)
    3. [Define user stories with the INVEST Framework or Who-What-Why or the Connextra Card Template – all are good and you do not need to be too rigid](#Define-user-stories-with-the-INVEST-Framework-or-Who-What-Why-or-the-Connextra-Card-Template-%E2%80%93-all-are-good-and-you-do-not-need-to-be-too-rigid)
    4. [Arrange core user stories into a Journey Map with a narrative flow or backbone of Big Activities moving from left to right](#Arrange-core-user-stories-into-a-Journey-Map-with-a-narrative-flow-or-backbone-of-Big-Activities-moving-from-left-to-right)
    5. [Task Backlog](#Task-Backlog)
    6. [Requirements Document and System Architecture Document](#Requirements-Document-and-System-Architecture-Document)
    7. [1 to 2-week Sprints](#1-to-2-week-Sprints)
    8. [Inline Testing](#Inline-Testing)
    9. [Demo and Playbacks](#Demo-and-Playbacks)
    10. [Acceptance with Sign Off and Cucumbers](#Acceptance-with-Sign-Off-and-Cucumbers)
    11. [Iteration and Incrementalism](#Iteration-and-Incrementalism)
    12. [Cup Cake Road Maps](#Cup-Cake-Road-Maps)
6. [Appendix Recommended Texts](#Appendix-Recommended-Texts)
--endContents

## Why Software Dev Guidebook

To help everyone in the Centre build great software, I've put together a collection of development guidelines to help you build scalable, maintainable, reliable, performant, and usable code. Like all guidelines, these are not strict rules, and knowing when and where to apply these guidelines largely comes down to practice and experience.  This is not an exhaustive list. For more in-depth analysis, please see the list of recommended texts in the appendix. I'm not going to repeat all that good advice here, that’s what the books are for, but I have tried to distil a range of key recommendations.

> [!TIP]
> Recognise that code is navigated and read far more than it is written, and that code is a form of expression designed for humans (machine code is for the machines).


_"Programs must be written for people to read, and only incidentally for machines to execute" Harold Abelson, the author of Structure and Interpretation of Computer Programs

### Target Audience

This guide is intended for folks who read and write code, mostly for the full-stack application/infrastructure domain. It is not possible to produce a ‘one size fits all’ set of guidelines for everyone. If you predominantly use Python/R via Jupyter Notebooks for example, much of this advice might be overkill, and for that reason, there is separate section for notebooks in the original guidebook. Recognise there are ways to bring more good software practices into Notebooks, see [https://nbdev.fast.ai/](https://nbdev.fast.ai/) which includes good stuff such as Git-friendly notebooks, built in support for CI/CD, support for tests as regular notebook cells and more.

Similarly, if you’re focussing on numerical computation in HPC using C/C++ or Fortran (formula translator), many of the guidelines are simply not appropriate; computational science is a very different domain to full-stack application development, each optimising for different priorities. Please bear this in mind, these are not rules, interpret them judiciously for your scenario, and as ever, the real answer is always “it depends”. I'll keep evolving this document and welcome any comments.

## High Level Recommendations 
### If it is not in Git it does not exist

- Use a GitLab/Github service - [https://gitlab.stfc.ac.uk/](https://gitlab.stfc.ac.uk/)
- Learn git concepts, not commands
- Branch early, commit little and often with ‘logically sensible commits’ multiple times a day.
- Use a dev branch for your main development and a main branch for your production releasable code.
- Use topic branches (aka feature branches) for your new developments.

#### Feature Branching vs Trunk Based development

Research by Forsgen & Humble (‘Accelerate’ book) shows that long-lived feature branches that remain open for prolonged periods of time hinder delivery and productivity. Team members are less likely to interact and merge conflicts are more likely. The general recommendation is to try and merge feature branches into dev every one or two days. However, the Accelerate book authors do acknowledge that longer lived feature branches are suitable for open-source development where committers are less likely to work full time on features, and so often need more long-lived feature branches.

![](attachments/Pasted%20image%2020240610204547.png)

[https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)

Tutorials: [https://github.com/davidmeredith/scdIntroToGit](https://github.com/davidmeredith/scdIntroToGit)

[top](#Table-Of-Contents)

[1] [https://github.com/davidmeredith/scdIntroToGit/blob/master/introToGit.pdf](https://github.com/davidmeredith/scdIntroToGit/blob/master/introToGit.pdf)

[top](#Table-Of-Contents)

#### Integrating Upstream Changes

There are two strategies to incorporating upstream commits from other branches - merging and rebasing.  Upstream commits are new commits that exist on another branch which need to be incorporated into your current branch to keep the branch up to date:

 a) Periodically merge the changes in the target branch (dev) into your feature branch. This creates the ‘braided’ graph pattern show opposite (flow is from top to bottom). When you’re ready to merge dev into master, a new merge-commit is created on the tip of the master branch.

 ![](attachments/Pasted%20image%2020240610204748.png)

b) As shown below, rebasing basically ‘breaks off the feature branch from its root (yellow), and re-attaches it to the tip of the target branch (grey)’. During the rebase, the commits that exist on the feature branch are internally used to create a set of diffs in temporary files which are used by git to create new updated versions of your feature commits. Git needs to do this in order to incorporate any upstream changes that may have occurred on the target branch.

![](attachments/Pasted%20image%2020240610204801.png)

[top](#Table-Of-Contents)

Note that rebasing does not delete the feature branch, the feature branch still exists, but it is now ahead of the target branch, by 2 commits in the diagram below. To bring the target branch up to date, a fast-forward merge is required on the target branch.

![](attachments/Pasted%20image%2020240610204811.png)

[top](#Table-Of-Contents)

#### Rebase vs Merge

Whether to rebase or merge is generally down to preference:

- Use ‘rebase’ to produce a clean and linear commit history. You can optionally use ‘interactive-rebasing’ and ‘squashing’ to clean up your commits too. Also observe the golden rule of rebasing: Don’t use rebasing if your feature branch is shared amongst multiple developers – rebasing essentially ‘pulls the rug from the under the feet of the other developers’ working on the feature branch.
- Use merge if you need to preserve a full history, for detailed auditing purposes for example. If this is the case, you probably don’t want to delete the feature branch after merging it, but you can do this later if needed.

[top](#Table-Of-Contents)

### Adopt Semantic Versioning for tags and releases

- [SemVer](https://semver.org/](https://semver.org/)

### Review each others code and be supportive

- Foster a friendly and supportive environment and politely shout-out vulnerabilities and apparent issues, don’t be shy. As a reviewer you’ll learn something. Code reviews and pair-programming really does improve code quality and exposure to different projects/codes/practices.

### If the critical path has not been reviewed it should not go onto master branch

- Basic code quality relies on having at least two pairs of eyes on code, to catch errors, suggest improvements, build shared knowledge, and improve code style.  Get into the habit of developing on branches or forks and using pull / merge requests to facilitate code review before merging.

[top](#Table-Of-Contents)

### Continuous Integration - If it does not have tests it does not work

- To be able to say something 'works' we judge it against some (implicit) criteria.  Writing tests makes our success criteria explicit.  Automation (Continuous Integration) prevents regressions.  Eventually, this leads towards test-driven development (TDD) where we think clearly about specifying what 'working' looks like up-front by writing code from a caller’s perspective.
- Test as you go along to a level that’s feasible and pragmatic. Extensive testing with production-level coverage (70 to 80%) is not always achievable or useful.  Given project budgets and timescales, focus on testing the application’s critical path as a minimum.
- Avoid gold-plating and focus on shipping code ASAP for customer review & feedback.
- Your Unit tests should be fast to complete – order of seconds.
- Do not just rely on unit tests - system and integration tests are also needed. Unit tests alone will instil a false sense of security.
- Integration and System tests can take longer to complete.
- For more details on best practices for testing, including the different types of testing from Unit, Integration to System tests, see: [https://epubs.stfc.ac.uk/work/50305274](https://epubs.stfc.ac.uk/work/50305274)

[top](#Table-Of-Contents)

### Continuous Delivery

Means that the software should always be in a releasable-ready condition.  This is a recommendation for your master and dev branches. If you’re run over by a bus (ROBAB), and someone must come along and pick up your code and they must fight with it from the outset, there’s a strong chance it will become shelfware.  If you need to have prolonged branches for experimentation that aren’t release-ready, create a feature branch such as ‘feature:homersSandbox’ to isolate your experiments. [https://epubs.stfc.ac.uk/work/47984368](https://epubs.stfc.ac.uk/work/47984368)

[top](#Table-Of-Contents)

### Continuous Deployment

Means that once the software is merged into master branch, it automatically gets pushed into production. The idea is to make the large and risky ‘big feature release’ a legacy practice.  By continuously deploying to production with small and frequent updates, if something goes wrong, its quick and easy to rollback.  This might be a stretch for Hartree because its more relevant for long-lived production software & products, not so appropriate for proof of concepts.

[top](#Table-Of-Contents)

### If it Does not have Documentation it is Not Usable

- Publish docs: Jira (task/sprints), Confluent (docs), GitLab, (code, merge requests, CI/CD), Bid register (PMO tracking tools)
- Use xDoc style code comments such as JavaDoc, PyDoc
- Document the intended purpose / intent of a function/class/package.
- If it’s tricky to document the intended purpose, then your class/function is likely too long and needs breaking down into smaller units.
- Always add a README.md.
- Always document inline - we _rarely_ go back and document our code after its written, fact.  
- End-users need to know how to use our software, so think about the right level of documentation for users. Consider separate user & developer docs.
- The C4 approach to technical diagrams is good. [https://c4model.com/](https://c4model.com/)
- For more details on how to write good documentation for different users including ‘How To’ Guides, tools such as Markdown/AsciiDoctor, and reference guide formats, see: [https://epubs.stfc.ac.uk/work/47984356](https://epubs.stfc.ac.uk/work/47984356)

[top](#Table-Of-Contents)

### Learning mindset

- Keep reading & learning and record all your training activities.
- Push beyond your comfort zone.
- Participate in RSE Skills & Learn sessions.
- Keep up the pursuit of software engineering craftsmanship, mastery and professionalism.
- Tinker - its really important to do hobby projects and dev stuff you enjoy.

### Customer Bill of Rights - modified from Uncle Bob Martin Clean Agile

Customers have the right to:

- An overall plan and to understand what can approximately be accomplished and at an estimated cost.
- Get the most possible value out of their projects.
- See progress in the development of a system.
- Change their mind, to substitute functionality, and to change priorities subject to agreement and re-scoping of the plan.
- Be informed of schedule and estimate changes, in time to choose how to reduce the scope to a meet a required date.
- Cancel at any time and be left with useful outputs reflecting their investment to date.

[top](#Table-Of-Contents)

### Developer Bill of Rights - modified from Uncle Bob Martin Clean Agile

- Developers have the right to:
- Know what is needed with clear declarations of priority.
- To always produce high-quality work.
- Ask for and receive help from peers, managers, and customers.
- Make and update their estimates at any time.
- Challenge the task and the responsibilities instead of having them assigned – professionals accept work, they are not assigned work. A professional developer has every right to say no to a particular job for various reasons, from ethical to overloading.
- Knowing ‘accepting work’ comes with a cost – acceptance comes with responsibility.  

[top](#Table-Of-Contents)

### Tooling

#### Do not be Smart - Use the Right Tools for the Job and for your customer

As a centre, we should be using the right tools for the job, we all have our preferences, but there’s no need to be stubbornly loyal about a particular language. As software professionals, we should recognise the right tools for the job and for our clients.  

Have the customer in mind. For example, Haskell and other Lisps are great (I’ve played with Clojure), but don’t be smart and use this as an opportunity to explore your favourite pet-programmer project, it’s not going to be much use to the customer. It’s hard to hire Haskell programmers.

##### To Garbage Collect or Not To GC

For certain types of programming, e.g. numerical algorithm development, HPC and when squeezing software into tight spaces such as embedded systems, a Garbage Collected (GC) language probably isn’t the best choice - a GC adds extra memory, disk, and CPU requirement. Therefore, venerable manual memory managed languages without a runtime such as C/C++/Fortran are still a good choice. Newer memory safe languages such as Zig, Rust, Mojo, Julia are interesting and relevant in this space, but I do not have enough hard-won experience in these languages to recommend them or not.

 For most other types of software development such as full-stack, enterprise, web services, mobile, and general-purpose programming, I do recommend using a memory safe language and this implies having a GC for the majority of languages (apart from Rust).  There is a recognised shift in industry away from memory unsafe languages as the vast majority Common Vulnerability Exploits (CVEs) stem from unsafe memory language exploits, causing organisations such as [Google](https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html) (for Android), [NSA and Microsoft to urge the use of memory-safe languages](https://www.theregister.com/2022/11/11/nsa_urges_orgs_to_use/), [DARPA through its 'TRACTOR' programme (Translating All C to Rust), and the US Gov](https://www.darpa.mil/research/programs/translating-all-c-to-rust) for all its  governmental projects to start all new projects in a memory safe language.

> [!TIP]
> “A human garbage collector is just wasted effort” (Eckle & Ward, Happy Path Programming). 
##### Monads and Green Threads need a GC

At the time of writing, there doesn't seem to be a non-GC language that supports monads for functional composition coupled with a colourless async runtime eg green threads and coroutines. Note, I do not mean platform/kernel/OS threads, I mean virtual or 'green' threads that are implemented by the runtime eg Go's Goroutines, Java's Project Loom, Fibres PHP and Ruby.  This appears to be a current open research topic in non-GC'd languages. According to this [Rust maintainer](https://www.youtube.com/watch?v=1zOd52_tUWg), async is possible with coloured approaches such as `async/await` (eg C++, Rust), but colourless approaches such as green threads and coroutines, and advanced functional programming with monads currently requires a GC. The GC handles memory clean-up for several low level complexities eg async task cancellation, how to implement memory clean up without higher-level approaches such as RAII and destructors, and providing a debugger that is usable for complex async code. I'm currently monitoring what Zig does in future - [here is an interesting summary](https://github.com/ziglang/zig/wiki/FAQ#what-is-the-status-of-async-in-zig), and apparently Zig's `defer/errdefer` becomes impractical in an async context. 

> [!NOTE]
For me, the increased productivity, and availability of a colourless async runtime with the ability to implement monads for functional composition is (currently) worth the cost of using a GC language, especially for application programming.

[top](#Table-Of-Contents)

##### What about Rust or Zig

TODO I don't have enough hard-won experience to confidently make this call, so I'll have to defer to the opinion of of others. According to Lars Bergstrom, Director of Engineering for Android at Google, 
[top](#Table-Of-Contents)
#### Kanban - Jira and Confluence

Keep all project documents and the Decision Point Review templates in a single repo such as Confluence so the client has full visibility. Its best if the client creates the (free) Jira instance and invites us as admins on their Kanban/Jira/Confluence. This way, the client has ownership of the project after the project completes. Make sure you export and download a copy of the Jira archive file so we can restore it within our own Jira instances if needed in future or for follow on projects.

![](attachments/Pasted%20image%2020240611092007.png)

[top](#Table-Of-Contents)

#### Gitlab and Version Control

For Hartree folks: Use the STFC Gitlab instance unless there is good reason not to: [https://gitlab.stfc.ac.uk/](https://gitlab.stfc.ac.uk/)

#### Container Repository

For Hartree folks: Use the STFC Harbor repository to upload and store containers: [https://harbor.stfc.ac.uk/](https://harbor.stfc.ac.uk/)

#### Build Tools

It is the developer’s responsibility to use an appropriate build tool that manages the dependencies of your project. It should be possible to clean the project, download dependencies, re-build a project, run unit and integration tests, and build a deployable package all from the command line. It is also the responsibility of developer to create the necessary environment configuration files (with specific version of modules or libraries) in a consistent state so that someone else can pick up your project easily.

[top](#Table-Of-Contents)

#### Static Code Analysis

Static code analysis helps bring consistency to your code. Within a project, adopt the same style guides and agree the linters up front e.g., Black for Python, Google style guide for Java are good examples. There’s no ruling here, pick one that suits the team and be consistent. There are plenty of static code analysis tools out there such as CheckStyle, FindBugs, SonarCube, Black, Google linter, IDE checks.

[top](#Table-Of-Contents)

#### Containerisation for Portability

Containers have become the de-facto way to mitigate the common claim “well, it works on my machine”. OCI compliant containers (Open Container Initiative) are great for wrapping code with all their dependencies into shareable images that can be uploaded to image repositories such as STFC’s Harbor service ([https://harbor.stfc.ac.uk/](https://harbor.stfc.ac.uk/)).  Containers are a great way to share code with your clients, especially if they need to run your code on their runtime platform. Containers are ubiquitous and can run on the Desktop, in Kubernetes clusters, in cloud Functions such as AWS Lambda, on HPC such as [Apptainer/Singularity](https://apptainer.org/), and more.

Here are some recommendations:

- Only include runtime dependencies: Be mindful of what you’re including in your container - for production, you really don’t need to include compilers, package managers, and tools that are meant for use only at compile time (unless you’re containerising your dev environment of course). For example, [Google’s Distroless](https://github.com/GoogleContainerTools/distroless) containers and [Alpine Linux](https://alpinelinux.org/) are great for production use, providing cut down versions of Linux.  Containers such as these are great because they have less memory-footprint, and by reducing the amount of unnecessary stuff in them, they reduce the vulnerability attack surface, so they’re safer. [Here’s a great video](https://www.youtube.com/watch?v=6wYrAtngIVo) that shows how to build super slim production containers – ignore the fact that it is for Java, the concepts and tools discussed are generic and apply for many languages.

- Don’t statically link glibc – use the [musl](https://musl.libc.org/) library instead. Glibc is notoriously unfriendly for containerisation and was not designed to be so.

- Don’t run your code within the container using the root user unless you really must.

- Use image layering to split up build time and run time dependencies. For example, having a separate 'build' and ‘run’ layers in your docker file allows you to copy only the built application code and dependencies into the container, leaving out all the unnecessary compile time dependencies. It also means you can re-run the container more quickly without having to re-build each time as build layers are built and cached locally.

- Testcontainers is awesome, download and run containerised apps/dependencies such as databases, services, tools and use them in your integration-test suites. Comes highly recommended: [https://www.testcontainers.org/](https://www.testcontainers.org/)

- See this great guide from the RSE team [for more info](https://softwareoutlook.ac.uk/best-practices-in-software-engineering/) on how to run HPC Singularity (now [Apptainer](https://apptainer.org/)) and Conda images with worked examples.

[top](#Table-Of-Contents)

#### Workflows and Containerisation

Please refer to this separate document that characterises all the different types of workflows we use at Hartree, including Data Flow Engines that orchestrate containers using DAGs (Directed Acyclic Graphs): [http://purl.org/net/epubs/work/50844906](http://purl.org/net/epubs/work/50844906). Our ‘[Demystifying Data Engineering](https://www.hartree.stfc.ac.uk/events/demystifying-data-engineering/)’ Explain course provides more details into Data Flow runtimes and tooling.

[top](#Table-Of-Contents)

## Coding Recommendations and Best Practices

This is not an exhaustive list of coding recommendations. For more in-depth explanations, please see the list of highly recommended texts in the appendix. I’m not going to repeat all that excellent advice here, that’s what the books are for, but please find below a collection of development best practices that we should consider when developing our software. Like all guidelines, they aren’t strict rules, knowing when and where to apply largely comes down to experience.

[top](#Table-Of-Contents)

### High Quality Code is Easy to Understand and Change

Code needs to achieve its purpose under certain parameters, but assuming that it does, what is high quality code?  There are many definitions, but I like "High quality code is easy to understand and change."  It implies the code is readable, it has good abstractions with well named constructs (classes, functions, variables, packages etc), and overall it is maintainable.  Watch [this](https://www.youtube.com/watch?v=F9owUy1g_YE&list=TLPQMjYwMTIwMjWZeuDaeoTSkA&index=6). 

- “Clean code does one thing well.”   (Bjarne Stroustrup)
- “Clean code reads like well written prose.”  (Grady Booch)
- “Clean code always looks like it was written by someone who cares.” (M. Feathers)
- “Getting code to work is only half your job, and it’s the least important part. The most important part is that you write code that other people can maintain/use. If you hand me code that works that I can’t understand, it is useless as soon as the requirements change.”  (Uncle Bob Martin). 

I'm not sure I agree with Uncle Bob on this one. Getting the code to 'work' first, especially for proofs of concept or blue-sky research code, is probably the higher prioirty.

Interestingly, The Primeagen seems to emphasise a slightly different point of view: "Not all code can be or needs to be made readable; it also depends on the skills of the programmer.” I believe this is __partly__ true, I acknowledge his point when applied to deeply numerical code or reactive JS for example, these types of code-bases are tricky to refactor for readability, but I als notice the push-back in the first comment on his video:  

![](attachments/Pasted%20image%2020250129141725.png)
[top](#Table-Of-Contents)

### Quality is the best shortcut - Fowler Design Stamina Hypothesis

- Think carefully about compromising the quality of your code for delivery speed; high quality code quickly becomes easier and faster to develop and overtakes hastily hacked together code. This is evidence based, see Martin Fowler's [Design Stamina Hypothesis](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)) which describes how the velocity of software development declines with time due to poor design. We have also experienced this before in actual projects – the hypothesis has played out in practice at Hartree.

![](attachments/Pasted%20image%2020240611092227.png)

[top](#Table-Of-Contents)

### Meaningful and Descriptive Names 

- “There are only two hard things in computer science, invalidation and naming things” (P.Karlton), see: [https://martinfowler.com/bliki/TwoHardThings.html](https://martinfowler.com/bliki/TwoHardThings.html)

> [!TIP]
> - Use intention revealing names for your abstractions, classes, functions & variables. 
>     - For example, `process_model` is too generic, what does it mean? `execute_nlp_training_model` is better, its more self-documenting.  
> - Don't use single character variable names
>     - Single chars for implicit loops etc are OK, but for global/module/class members, please use sensible names.  
> - Class names should have noun phrases e.g., Customer, WikiPage, Account, AccountParser.
> - Don't name abstractions after constituent parts.
> - API comments should describe the intention, not the implementation or how (internal comments ok) 
> - Don’t write comments when you can use a well named function or variable.

The following two examples are taken from Uncle Bob's 'Clean Code' book:

#### Use Intention Revealing Names
Which is easier to read? 
```Java
// check to see if the employee is elibible for full benefits

// This
if((employee.flags & HOURLY_FLAG) && employee.age > 65) {
   ...
}

// Or this?
if(employee.isEligibleForFullPension()){ 
  ...
}
```

#### Considered Comments 

I have mixed feelings about this piece of advice from Uncle Bob: "Every time you express yourself in code, you should pat yourself on the back. Every time you write a comment, you should grimace and feel the failure of your [lack] of ability of expression."  Bob goes on to explain that you should use well-named variables instead of comments, as shown in the example below (real-estate limits apply - imagine a much larger example). I understand the sentiment here, but I think it can be easily misinterpreted - I believe we do still need comments, and they should focus on the intention, not the 'how.'

```Java
// For our system, we need to get all the depndent systems 
// and see if our sub-system is dependent on it. 
if(this.getSystems().contains(this.subSystems.current())){ 
   ...
}

var allSubSystems = this.getSystems();
var ourSystem = this.subSystems.current();

if(allSubSystems.contains(ourSystem)){
  ...
}
```

[top](#Table-Of-Contents)

#### Do Not Name Abstractions After Constituent Parts

- Do not name abstractions after their constituent parts using a 'bottom up' approach. By definition, an abstraction should use a higher level vocabulary and shield you from the lower level details. Gregor Hohpe from 'Enterprise Application Integration' book fame provides a great example: If software engineers had named the automobile, it would have been something like: `PistonCrankshaftGearWheelAssemblyFactorySingleton` - not a useful name (this reminds me of some Spring Framework classes).  Another simple example from Gregor: Q. consider the `GasPedal` of the car, is that a good abstraction? A. no, the car might not use gas, a more suitable name is the `Accelerator.`     

[top](#Table-Of-Contents)
### Testing has Three Main Purposes

> [!TIP]
> Testing has 3 main purposes: 
> 1) To assert the correctness of your code.
> 2) To prevent regressions.
> 3) To encourage good design.


- 1) **To assert the correctness of your code**. Sometimes you might counter “well, it’s not always possible to know the result of a calculation to assert because the result is non-deterministic”.  In this scenario, the following reasons to test still hold true!
- 2) **To prevent regressions.** It really does build confidence in your code if you can quickly run a test suite to make sure you haven’t unexpectedly broken something.
- 3) **To encourage good design.**  It _really_ does actually - there’s lots of supporting research that shows this. When you write tests, you put yourself in the caller's perspective, so you really do think about design such as loose coupling, separation of concerns, modularity, simplicity of API, and so on. If your code is hard to test, it’s likely too strongly coupled, and here Dependency Injection with abstractions can help you.  Test Driven Development (TDD) is the ultimate testing practice, where you write tests first using an imaginary API, and then you fill in the details.

[top](#Table-Of-Contents)

### Keep Classes and Functions Smallish

General rule – not much bigger than your screen’s viewport. I don't subscribe to certain views that functions should be no longer than four or five lines myself - I find it too difficult to hop around the code when functions are this small.   However, a viewport size / page is fine, and if you still need convincing, know that compilers can apply far more effective in-lining optimisations with smaller classes and functions.

[top](#Table-Of-Contents)

### Limit the Number of Function Arguments

>[!TIP]
>Consider using immutable Data Transfer Objects (aka DTOs / Data Objects / Records) if your function has more than ~4 arguments, and nesting these gives good structure.

### Separation of Concerns for Locality of Behaviour 

Functions should do one thing. For some functions this is true, especially low-level functions for example. However, I don't believe this is a unanimous rule. Higher-level functions (the outer layer in the dependency bullseye) often compose multiple child functions to achieve an end result. For example, consider a controller that composes multiple service facade calls to provide a final response.  

>[!TIP]
>I prefer: Functions should separate concerns to give Locality of Behaviour. LoB means that code is easily understood by looking at only a small portion of it (paraphrasing R. Gabriel)

The following example is from 'Modern Software engineering' (Dave Farley): There are three implementations of an `add_to_cart` method that performs three tasks (please ignore the function suffixes which are just to illustrate this example): 
- 1) adding an item to the cart, 
- 2) persisting the card to a DB, and 
- 3) calculating the total cost of the cart. 

Example 1 is very poor, it mixes all three concerns directly and you need to understand the low-level details to understand what is happening. Example 2 is much better - logic is abstracted into private methods with descriptive names that 'reads the logic,' this is far easier to follow. Example 3 is even more loosely coupled - is this an improvement over version two, probably not for this simple example, but you can see how this further decouples concerns. Example 3 is a nice pattern for complex systems - it is easy to add new event listeners to react accordingly without having to change the logic of the function. 

```Python
def add_to_cart_poor(self, item):
    self.cart.add(item)
    
    conn = sqlite3.connect('my_db.sqlite')
    cur = conn.cursor()
    cur.execute('INSERT INTO cart (name, price) values (item.name, item.price)')
    conn.commit()
    conn.close 

    return self.calculate_cart_total(); 


def add_to_cart_good(self, item):
    self.cart.add(item)
    self.store.persist_item(item)
    return self.calculate_cart_total(); 


def add_to_cart_extensible(self, item, listener):
    self.cart.add(item)
    listener.on_item_added(self, item)
```
[top](#Table-Of-Contents)

### Information Hiding - Deep Rather than Shallow Interfaces 

TODO. 

### Code Should be Cohesive

> [!TIP]
Code should be cohesive which is related to the Single Responsibility Principle. High cohesion means the methods and variables of  a class are co-dependent and often change together. This can be paraphrased as "Changes to the code over here should not affect code over there" and "Code that changes together stays together." Another useful interpretation: "When you want to add something, you intuitively know which class should be modified."

Here’s the authoritative view from the famous [Kent Beck from Nov (2022) and his ‘Tidy First’ approach to software development:](https://twitter.com/KentBeck/status/1587825849755049984)

![](attachments/Pasted%20image%2020240611092926.png)

Examples of patterns that support cohesion include the State Pattern.

- In the State pattern, consider code that is widespread across many files with each file having 'switch' or 'when' statements that reference a centrally declared enum set. The switch/when statements execute different behaviours based on the current enum state value. If you add or remove a state enum option, you will need to update the all switch/when statements that are spread across your code-base. This is not a problem for small projects, but for large code bases it can require significant refactoring. The state pattern co-locates the state enum values with the associated behaviour. To do this, the central enum set could be replaced with a corresponding set of state objects, where each state object collects and implements the relevant state-dependent behaviour itself. 

TODO - provide an example 

[top](#Table-Of-Contents)
### OOP Redefined 

OPP is about "Program organisation" (Bjarne Stroustroup). 

The OOP data model of class inheritance hierarchies and interface implementations has, undoubtedly, proven to be highly effective in modelling real-word data, largely due to its frequent natural fit for representing real-world objects, and also due to its expressiveness. OOP still dominates compared to other programming paradigms such as functional and procedural. OPP helps you to organise programs around data and the actions that are intended to operate on that data. From my perspective, what I like about OOP is that it is really clear how to organise my program around classes - locating the data alongside the functions that operate on that data is very common and often feels natural. Without classes, you can lose some of this clarity, especially in large programs. However, OPP is not the only option. Other paradigms such as Functional, Procedural, and Data Orientated Programming exist. I'm not a purist - I believe you can and should apply all these paradigms when it is most convenient to do so. Most general purpose programming languages allow you to mix paradigms to some extent. 

OOP bashing appears to be popular these days, but this is mostly because of the problems associated with hierarchical inheritance (see section on Don't Pay Too Much Inheritance Tax), and I agree that hierarchical inheritance should be applied judiciously. However, I believe that most of the other OOP principles are tried, tested, and proven. You can’t argue against three of the four 'pillars' of OPP: Abstraction, Encapsulation, and Polymorphism. These are good design principles largely available across all modern programming languages.  Arguably, what pure OOP can over-emphasise is deep & brittle inheritance hierarchies, but instead you can favour composition instead in the right scenarios.

| Pillar                            | Implementations                                                                                                            |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| Abstraction                       | Interfaces, Traits, Service Facade                                                                                         |
| Encapsulation                     | Classes, Records/struts/nested-structs, Closures, Modules, Public/Private/Protected visibility, monads (wrap side-effects) |
| Polymorphism                      | Inheritance, ADTs, Type-classes, Generics & Parametric Polymorphism, Interfaces/Traits, Dynamic-Dispatch                   |
| ~~Inheritance~~ Sharing Behaviour | Composition / Delegation, Traits, Default Interfaces, Inheritance                                                          |

I believe inheritance should be replaced with 'Sharing Behaviour': the other pillars are generic to accommodate multiple implementations and inheritance is not the only way of sharing code across types. Other ways to share code include Composition (available any language), traits (Scala, Rust), interfaces with default implementations and attributes (Java, Go, Py), and type-classes (Scala), to name a few. I agree that inheritance can be overdone, but it does have it place (see section on 'Don't pay too much inheritance tax').  

### SOLID

For OPP, understand the principles of SOLID:
| SOLD  | Meaning |
| -------------- | --------------- |
| Single Responsibility Principle (SRP) | A module should be reponsible to one, and only one, ACTOR (Bob Martin's reinterpretation) |
| Open-Closed Principle |  Classes should be explicitly designed for extension and can't be unintentionally modified.|
| Barbara Liskov’s Substitution principle |  A subclass can substitute for its parent, this mostly surfaces when chaining function calls. Requires all behaviour, public members (API and variables), invariants and post-conditions to be the same, commonly requires inheritance. |
| Interface Segregation Principle|  Separate interfaces to focus on just a single concern.|
| Dependency Inversion |  Abstractions should not depend on details, but details should depend on abstractions. To do this, an abstraction layer (interface) is extracted to separate high and low level modules. |

#### SRP

A common misinterpretation of SRP is "One function/class should only do one thing." While I don't disagree with this advice, its not actually what the SRP was getting at. The formal interpretation is "A module should have one, and only one, reason to change." This is a touch ambiguous, I prefer Uncle Bob Martin's reinterpretation "A module/class should be responsible to one, and only one, ACTOR" (because the reason to change comes from the actor, a useful clarification in my opinion). In Bob's great book, Clean Architecture: A Craftman's Guide to Software Structure and Design, Bob illustrates a violation with an Employee class that mixes three business rule methods, where each is required by a different actor: `calculatePay()` for the Finance team, `reportHours()` for HR and `save()` for Operations. Under the hood, these methods could refer to some common private logic eg `regularHours()`, however, this type of de-duplication by consolidating common code into a shared function can often become a source of bugs, especially for complex code which spans different dev teams which requires merging of different VCS branches. SRP says don't do this, instead separate the code that different actors depend on, even at the expense of some intentional duplication.

> [!TIP]
SRP is closely related to cohesion: "Code that changes together stays together" and when you want to implement SRP think "It should be easy to identify which class should be modified if I want to change something."

A solution to the Employee class violation example would be to use a data object that holds nothing but the employee data (no methods) and move the behaviour into separate facade(s) for processing business rules, one for each actor for example (`PayCalculator` `HourReporter` and `EmployeePersistor`). Notice that this solution is the end of a spectrum of possible solutions - Bob does explain that some developers or in some scenarios you may prefer to keep the most important business rules close to the data. In this case, the original `Employee` class can still contain the three business rule methods, but these methods are very short and simply delegate to the appropriate business rule calculator facades under the hood (Composition).  

> [!TIP]
Don't define a new data type (class) solely as a container for a *single* function to do something. This is overkill - just write functions and call them. 

Don't do this: 
```C#
class ToUpper : ICharacterTransform
{
    public char Transform(char c) => char.ToUpper(c);
}

class ToLower : ICharacterTransform
{
    public char Transform(char c) => char.ToLower(c);
}
```
[top](#Table-Of-Contents)

#### Open-Closed Principle

OCP is relevant only for classic hierarchical class extension, however, as we prefer object composition over inheritance these days, this principle has less relevance in modern software engineering. You should explicitly make classes non-extendable by default meaning you explicitly have to design classes for inheritance when you need to.

### Pervasive Polymorphism

What does polymorphism mean to you? For those with background in OPP, you most likely think of inheritance using an abstract base-classes with sub-type specialisations. However, I agree with [Bruce Eckle](https://www.youtube.com/watch?v=ojffu0F_aQQ) in that it should be regarded as a much broader term, and polymorphism can crop-up all over: 

> [!TIP]
Don't limit your understanding of Polymorphism to inheritance alone, it broadly means that '__a single type can represent multiple types__.'

If we acknowledge this interpretation, then polymorphism can include: 
| Polymorphism type   | Description|
|--------------- | --------------- |
| Inheritance | Classic inheritance hierarchies with base class & sub-type specialisations  |
| Union/Sum Types  | A type must be one from a selection of types to implement choice|
| Parametric (often implies Composition) | A 'marker type' is ***attached to a type*** to represent another type, often by composing objects |
| Structural Typing / Protocols | A type is ***compatible*** if has methods that correspond to an interface protocol, with compile-time checks (eg Go)  |
| Duck Typing | Same as Structural Typing with dynamic-dispatch (eg Python)|

#### Inheritance is Solely for Strong 'Is A' Type Relationships to Maintain State Invariants and Post-Conditions 

> [!TIP]
A common mistake is to assume inheritance is mainly for sharing behaviour. It is not, it is for inheriting all public and protected members including state variables and, importantly, maintaining all invariants and post-conditions. 

The Liskov substitution principle mandates this - it should be possible to replace a parent object with any of its sub-types. The sub-type must therefore maintain all public members including methods and state, and all invariants (i.e. conditions and relationships across all state that hold true), and all post-conditions (i.e. the invariants hold after object construction and after applying behaviour). Inheritance is the mechanism that enables this. Inheritance should be reserved only for strong and natural 'is a' types of relationships. It can be over-applied, in fact you often do not need inheritance and should share behaviour using parametric polymorphism instead. As a memory aid, if you define a super class `Bird`, you would think adding the `fly()` method would be appropriate, but no, not all birds can fly and some can swim, so flying is a behaviour better added as by the `Flyer` interface, so `Penguine` can omit `fly()` (and also apply the `Swimmer` interface). 

[top](#Table-Of-Contents)

#### Inheritance Should be Explicitly Designed For

By default, in some languages you can extend a class by default, unless you explicitly disallow it e.g., using the `final` keyword in Java or through object and interface Sealing. In modern languages, classes are typically closed to extension by default.  For example, in Kotlin you have to explicitly enable class extension using the `open` keyword to make it explicit that this class is designed to be extended. This makes SOLID’s 'Open Closed Principle' best-practice explicit in the language.  

[top](#Table-Of-Contents)

#### Avoid Paying too much Inheritance Tax - Use Parametric Polymorphism to Augment your Type-System With Shared Marker Types

> [!TIP]
By design, inheritance is an intentionally a strong 'is a' relationship; For a sub-type to act as its parent type (Liskov substitution principle), then it needs to maintain the same behaviour, and same invariants and post-conditions. A common mistake is to focus just on behaviour, inheritance is more than that.

> [!TIP]
I say "don't pay too much inheritance tax" intentionally because inheritance is great in certain scenarios such as in building frameworks, libraries, and for strong/natural "Is a" relationships e.g. "type A is a type of B." A great example is the 'Either' monad - the Left/error and Right/success objects inherit from the Either base class, so an Either can be Left or Right, but never both. 

However, deeply nested inheritance hierarchies where sub-classes extend super-classes can become very brittle. This is because you are structurally tied to the classes in the parent hierarchy: 
  - If you don't need all of the characteristics provided through inheritance, it can be difficult to 'split-out' what is not wanted without widespread refactoring. 
  - Some languages (eg Java) do not allow multiple inheritance which could encourage deeper inheritance hierarchies. 
  - If you don't have access to the src of the parent hierarchy, you may be forced to implement abstract methods you don't need, typically by throwing unsupported exceptions/errors. 

If you do have access to the src of the parent hierarchy, you may need to extract the required methods into a new level and inherit from that level to facilitate better segregation of concerns e.g., from the direct parent if you do want those methods, or from a higher-level ancestor if you do not need every method. This can be an expensive refactor meaning deep inheritance is often considered an anti-pattern these days, especially for application developers. A number of modern languages don't even support inheritance. Having said that, inheritance arguably does have its place when developing libraries and frameworks, and especially for relationships that have a strong and natural "Is a" type of relationship e.g., 'typeA is a genuine / real sub-type of typeB.'

> [!TIP]
Rather than pay too much inheritance tax, consider using 'Parametric Polymorphism' where a 'marker type' attaches a contract which allows a type to be represented as another type. This shared marker type augments your type-system for use in function parameters, return values, and attribute declarations, often in conjunction with generics ('holder types'). The canonical name for this type of polymorphism is "parametric polymorphism," "generic programming" or "ad-hoc polymorphism." It is typically implemented with dynamic-dispatch and is often used in conjunction with Composition under the hood where an object uses the functionality of another object to implement its behaviour.  

The mechanism for sharing code varies across languages and includes Interfaces (eg Java), Traits (eg Rust), Mixins (eg Python), and Type-Classes (eg Scala). Often, composition is used under the hood to share behaviour. Several modern languages don’t even support inheritance (Rust, Zig, Go), relying instead on parametric polymorphism.

| Parametric Polymorphism                                                          | Inheritance                                                                                                         |
| -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| Interface segregation is finer grained - you choose what to implement            | You may need to inherit everything from all ancestors (note, this might be the intention as per Liskov substituion) |
| More loosley coupled, changes to an attached trait does not affect other traits. | Tightly coupled - changes in the parent hierarchy can vertically affect all sub-types                               |
| More flexible - attach multiple marker types                                     | Single inheritance in some languages is more restrictive                                                            |

![](Pasted%20image%2020241220110926.png)

#### Parametric Polymorphism for Existing Types

The mechanism for attaching marker types varies across languages. Some languages allow you to attach the marker type onto existing types without having to modify the original type. This is very convenient and powerful for easily creating '*blanket implementations*,' and when you don't have access to the src code of those types e.g., types defined in external packages. Rust and Scala lexically split their type definitions from the definition of the attached marker type using an additional 'referencing-layer.' Conversely, Kotlin and C# provide extension functions to extend the behaviour of existing (or custom) types, which is a subtly different approach that achieves a similar outcome (you can still also define your own custom interface and use extension-functions and composition to achieve the same result as Rust traits). 

> [!TIP]
Lexically splitting a type from a marker type via an extra 'referencing layer' is elegant and powerful compared to implementing the marker directly on the original type definition itself, such as implementing an interface directly on a class declaration. This is because you don't need to modify the existing type which facilitates simple blanket implementations, and when you do not have access to the src code of the original type. If that extra layer of indirection feels a touch unnatural or overkill, you can easily co-locate these individual component parts near to each other in the same file to achieve that familiar class feel.

```Rust
use externalcrate::SomeStruct;    // here is our existing type

trait Length {                    // A marker trait for shared behaviour
  fn get_length(&self) -> u32;
}

impl Length for SomeStruct {      // A referencing layer that attaches Length to SomeStruct
  fn get_length(&self) -> u32 {
    self.to_string().len() as u32
  }
}
```

[top](#Table-Of-Contents)

#### Extensions for Augmenting Existing Types

Some languages allow you to extend the existing types using extension functions and properties e.g., C# and Kotlin (the latter learning from the former). Extension functions and properties can be grafted onto existing types even if you don't have access to the source code for those types. 

>[!TIP]
>One of the primary intentions of extensions is to keep core abstractions small by not polluting them with your own customisations, this way the original abstraction keeps their original behaviour (Andrey Breslav, original Kotlin language designer).

Notice that in the example below, `swap` is grafted onto the existing `MutableList` interface. All other references to `MutableList` can call `swap` creating a blanket implementation without polluting the original. Similarly, all list implementations can access the `lastIndex` extension property.

```Kotlin
// Extension property on Kotlin's existing List Interface to store a custom description
var <T> List<T>.description: String   
    get() = this.description  
    set(newDescription): Unit { this.description = newDescription }  
  
// Extension function on kotlin's existing MutableList Interface to swap specified elements 
fun <E> MutableList<E>.swap(index1: Int, index2: Int): Unit {  
    val tmp = this[index1] // 'this' corresponds to the list  
    this[index1] = this[index2]  
    this[index2] = tmp  
}  
  
fun <E> consumer(mutableList: MutableList<E>, index1: Int, index2: Int) {  
    mutableList.swap(index1, index2)  
    mutableList.description = "My cool new list to store bikes"  
    println(mutableList.description)  
}
```
[top](#Table-Of-Contents)

#### Structural Polymorphism and Duck Typing

Some languages have have ‘Duck Typing,’ this is like using an interface at a call site (eg the type of a function parameter or return value), but *does not require you to explicitly define a contract on a type using scaffold code* such as `class A implements interfaceB` (Java) or `impl traitB for typeA` (Rust). Instead, a particular type implicitly implements an interface if has the corresponding methods available: “if it walks and swims like a duck, it’s probably a duck,” otherwise an error is generated. If the type checking occurs at compile time, it is often called ‘Structural Typing/Polymorphism’ eg `Template` classes in C++ and in Go. If type checking occurs at runtime and produces runtime errors, it is called "Duck typing" which is more common in dynamic languages.  

>[!TIP]
The ease and speed of development that duck typing brings is great for scripting and smaller code bases, but as the size and complexity of the code increases, I would advise using scaffolding code for stronger compile time type checking (for Pythonistas, you can always introduce static typing such as Python’s optional type hints, and for Go, see the code in the 'Go Example' above for a tip to check a type implements an interface). 

[top](#Table-Of-Contents)

#### Sealing 

Some languages allow the developer to seal interfaces/classes/types in order to restrict the range of allowed subtypes. 

>[!TIP]
Why sealing? Limiting the extensibility of types is a useful feature for domain modelling when code reuse is not a goal. Instead, the restriction of subtypes to a known set helps comprehension, clarity, type misuse, and security. Sealing mitigates the need for defensive coding for unknown subtypes, and is useful for increasing the security of libraries. It facilitates exhaustive `when` and/or `switch` case patterns for Algebraic Data Types (see ADTs below).

As a simple example, consider a sealed result class that has a fixed number of subtypes to indicate different kinds of results. You can react to the different results via exhaustive when/switch patterns. In another domain modelling example, consider subtypes of the class `Shape` - the author may be interested in the clarity of code that handles known subclasses of Shape, and is not interested in writing defensive code for unknown subclasses of `Shape`.

[top](#Table-Of-Contents)

#### Composition / Delegation

>[!TIP] 
>A complex term that in practice simply means that one class contains or is passed an instance of another to use its capabilities. 

> [!WARNING]
Unless your language supports duck-typing, composition alone may not establish a polymorphic type without the addition of additional scaffolding code such as an interface or trait. 

[top](#Table-Of-Contents)


### Parametric Polymorphism Language Comparison

I feel demonstrating parametric polymorphism across a selection of languages is a useful endeavour because it also demonstrates several related concepts such as interfaces/traits, composition, extension methods, union types and sealing.  

##### Rust Example

Arguably, Rust has one of the most powerful type systems available (I think Kotlin is comparable). We will start with Rust and follow with examples from other programming languages.

The detailed example below demonstrates:
- Default method implementations on traits.
- Optional method overriding.
- Trait composition and implementing multiple traits - see `Product`.
- Extension Trait to augment existing types - see `StringExt`.
- Generic functions and trait bounds - see `filter_items`.

```Rust
// Rust Parametric Polymorphism
use std::fmt;

// Printable trait with default and required methods
trait Printable {
    // Default method implementation
    fn pretty_print(&self) -> String {
        format!("[Default pretty_print: {:?}]", self.format())
    }
    // Required method to implement
    fn format(&self) -> String;
}

// Serializable trait with default methods
trait Serializable {
    fn serialize(&self) -> String;

    // Default validation method
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}

// Custom error type for validation
#[derive(Debug)]
struct ValidationError {
    message: String,
}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ValidationError {}

// Product struct implementing multiple traits
#[derive(Debug, Clone)]
struct Product {
    name: String,
    price: f64,
    quantity: i32,
}

impl Printable for Product {
    // Implementing required format method
    fn format(&self) -> String {
        format!(
            "{} (Price: ${:.2}, Quantity: {})",
            self.name, self.price, self.quantity
        )
    }

    // Optional override of pretty_print
    fn pretty_print(&self) -> String {
        format!("[Product: {}]", self.format())
    }
}

impl Serializable for Product {
    fn serialize(&self) -> String {
        format!(
            "Product{{name={},price={:.2},quantity={}}}",
            self.name, self.price, self.quantity
        )
    }

    // Custom validation implementation
    fn validate(&self) -> Result<(), ValidationError> {
        if self.price < 0.0 {
            return Err(ValidationError {
                message: "Price cannot be negative".to_string(),
            });
        }
        if self.quantity < 0 {
            return Err(ValidationError {
                message: "Quantity cannot be negative".to_string(),
            });
        }
        Ok(())
    }
}

// Display trait for pretty printing
impl fmt::Display for Product {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.format())
    }
}

// Inventory management trait
trait InventoryManager {
    fn is_low_stock(&self, threshold: i32) -> bool;
    fn restock(&mut self, amount: i32);
}

impl InventoryManager for Product {
    fn is_low_stock(&self, threshold: i32) -> bool {
        self.quantity < threshold
    }

    fn restock(&mut self, amount: i32) {
        self.quantity += amount;
        println!("Restocked {} by {} units", self.name, amount);
    }
}

// Extension trait for string manipulation
trait StringExt {
    fn truncate(&self, max_length: usize) -> String;
    fn word_count(&self) -> usize;
}

impl StringExt for str {
    fn truncate(&self, max_length: usize) -> String {
        if self.len() <= max_length {
            self.to_string()
        } else {
            format!("{}...", &self[..max_length])
        }
    }

    fn word_count(&self) -> usize {
        self.split_whitespace().count()
    }
}

// Generic filter function similar to Go's FilterItems
fn filter_items<T, F>(items: &[T], predicate: F) -> Vec<T>
where
    // Trait bounds used to constrain the generics F and T
    F: Fn(&T) -> bool,
    T: Clone,
{
    items
        .iter()
        .filter(|&item| predicate(item))
        .cloned()
        .collect()
}

fn main() {
    // Create products
    let laptop = Product {
        name: "MacBook Pro".to_string(),
        price: 1999.99,
        quantity: 5,
    };

    let keyboard = Product {
        name: "Mechanical Keyboard".to_string(),
        price: 129.99,
        quantity: 2,
    };

    // Demonstrate trait methods
    println!("Pretty Print: {}", laptop.pretty_print());
    println!("Serialized: {}", laptop.serialize());

    // Validation demonstration
    match laptop.validate() {
        Ok(_) => println!("Validation passed"),
        Err(e) => println!("Validation Error: {}", e),
    }

    // Demonstrate extension trait
    let long_string = "This is a very long string that needs truncation";
    println!("Truncated: {}", long_string.truncate(10));
    println!("Word count: {}", long_string.word_count());

    // Demonstrate polymorhpic filtering
    let products = vec![laptop.clone(), keyboard.clone()];
    let low_stock_products = filter_items(&products, |p| p.is_low_stock(3));
    println!("Low Stock Products:");
    for mut p in low_stock_products {
        println!("{} - Quantity: {}", p.name, p.quantity);
        p.restock(10);
    }
}

```
[top](#Table-Of-Contents)

##### Kotlin Example

Kotlin provides a similar approach to Rust's polymorphic traits through a combination of:
- interfaces with default methods
- optional overrides
- extension functions for extending existing and custom types directly, whether on the type or an interface (this is a slightly different approach to Rust which requires a trait definition)
- Sum/Union type implemented with sealing to model choice (also available in Rust)

This combination is very powerful, facilitating type augmentation and dot completion for extension method findability.

```Kotlin
package org.example

import org.example.ValidationResult.Success
import org.example.ValidationResult.Failure

// Kotlin Parametric Polymorphism

// Rust-like trait implemented with a Kotlin interface using default methods on interfaces & extension methods
interface Printable {
    // Default method implementation similar to Rust trait methods
    fun prettyPrint(): String {
        return "[$this]"
    }
    // Abstract method that implementing classes must define
    fun format(): String
}

interface Serializable {
    fun serialize(): String
    // Default Validation method
    fun validate(): ValidationResult {
       return Success("Validation passed")
    }
}

// Extension function to add functionality to existing types
// This is similar to Rust's trait methods that can augment existing types
fun String.truncate(maxLength: Int): String {
    return if (length <= maxLength) this
    else substring(0, maxLength) + "..."
}

// Extension function with more complex logic (see section on Extension Functions)
fun String.wordCount(): Int {
    return trim().split("\\s+".toRegex()).size
}

// Sealed class to demonstrate exhaustive behavior (see section on Sealing)
sealed class ValidationResult {
    data class Success(val message: String) : ValidationResult()
    data class Failure(val error: String) : ValidationResult()
}

interface InventoryManager {
    fun isLowStock(threshold: Int): Boolean
    fun restock(amount: Int)
}

data class Product(val name: String, val price: Float, var quantity: Int) :
    Printable, Serializable, InventoryManager {

    override fun format(): String {
        return "$name (Price: $price Quantity: $quantity)"
    }
    override fun serialize(): String {
        return "Product{name=$name,price=$price,quantity=$quantity}"
    }
    // Custom validation implementation
    override fun validate(): ValidationResult {
        return when {
            name.isBlank() -> Failure("Name cannot be blank")
            price < 0 -> Failure("Price cannot be negative")
            else -> Success("Product is valid")
        }
    }

    override fun isLowStock(threshold: Int): Boolean {
       return this.quantity < threshold
    }

    override fun restock(amount: Int) {
        // TODO make thread safe
        this.quantity += amount
        println("Restocked $name by $amount units")
    }
}

// Demonstrate Extension method on an existing List interface - similar to a Rust extension trait
fun List<Product>.filterValidProducts(): List<Product> {
    return filter { it.isLowStock(3) }
}

// Demonstration of type augmentation and trait-like behavior
fun main() {
    // Create products
    val laptop = Product("MacBook Pro", 1999.99f, 5)
    val keyboard = Product("Mechanical Keyboard", 129.99f, 2)

    // Demonstrate extension functions
    val longString = "This is a very long string that needs truncation"
    println(longString.truncate(10))
    println(longString.wordCount())

    // Validation demonstration
    val validationResult = keyboard.validate()
    when (validationResult) {
        is Success -> println("Validation passed: ${validationResult.message}")
        is Failure -> println("Validation failed: ${validationResult.error}")
    }

    // Demonstrate trait methods
    println("Pretty Print: ${keyboard.prettyPrint()}")
    println("Serialised: ${keyboard.serialize()}")

    // Demonstrate polymorphic filtering
    val products = listOf(keyboard, laptop)
    println("Low stock items: ${products.filterValidProducts()}")
    laptop.restock(10)
}
```
[top](#Table-Of-Contents)

##### Java Example

While Rust-like traits are elegant and powerful, you can achieve a similar effect using a combination of interfaces with default method implementations, and a mixture of composition and inheritance. As you can see in the Java example below, there is a lot more boilerplate. Java's approach is still not as powerful as Rust and Kotlin's approaches which allow automatic 'blanket implementations' on existing types and trait/extension-function inheritance.

Limitations:
- Extension of existing types from another package may not be possible (eg final classes).
- No trait or extension-function inheritance.
- May need to use a combination of composition or inheritance to augment existing types, which may not be as convenient as attaching marker types. 

```java

import java.util.List;
import java.util.concurrent.locks.ReentrantLock;

// Java Parametric Polymorphism

interface Printable {
    // Default method implementation - similar to Rust trait methods
    default String prettyPrint() {
        return "[Default Pretty Print: " + this.format() + "]";
    }
    // Abstract method that implementing classes must define
    String format();
}

interface Serializable {
    String serialize();
    default Result validate() {
        return new Ok();
    }
}

sealed interface Result permits Ok, Err { }
record Ok() implements Result {}
record Err(String err) implements Result {}


interface StringExtensions {
    // Default method that can be "mixed-in" to any non-final class
    default String truncate(int maxLength) {
        if (this.toString().length() <= maxLength) {
            return this.toString();
        }
        return this.toString().substring(0, maxLength) + "...";
    }
}

// Because String is final, we can't extend String so we have to compose it
// in order to implement StringExtensions
record MyExtendedString(String str) implements StringExtensions {
    @Override
    public String truncate(int maxLength) {
        if (str.length() <= maxLength) {
            return str;
        }
        return str.substring(0, maxLength) + "...";
    }
}

interface InventoryManager {
    boolean isLowStock(int threshold);
    void restock(int amount);
}

class Product implements Printable, Serializable,  InventoryManager {
    String name;
    Float price;
    Integer quantity;
    ReentrantLock re;

    public Product(String name, Float price, Integer quantity){
        this.name = name;
        this.price = price;
        this.quantity = quantity;
        this.re = new ReentrantLock(true);
    }

    @Override
    public String toString(){
        return this.name;
    }
    @Override
    public String format() {
        return this.name+" (Price: $"+this.price+", Quantity: "+quantity+")";
    }
    @Override
    public String prettyPrint(){
        return "Product: "+this.format();
    }
    @Override
    public String serialize() {
        return "";
    }

    @Override
    public Result validate() {
        if(this.price < 0.0f) {
            return new Err("Price cannot be negative");
        }
        if(this.quantity < 0){
            return new Err("Quantity cannot be negative");
        }
        return new Ok();
    }

    @Override
    public boolean isLowStock(int threshold) {
        return this.quantity < threshold;
    }

    @Override
    public void restock(int amount) {
        try {
            re.lock();
            this.quantity += amount;
        } finally {
            re.unlock();
        }
        System.out.println("Restocked "+name+ " by "+amount+" units");
    }
}

// Demonstration class
public class Main {
    public static void main(String[] args) {
        // Create products
        Product laptop = new Product("MacBook Pro", 1999.99f, 5);
        Product keyboard = new Product("Mechanical keyboard", 129.99f, 2);

        // Demonstrate trait/interface methods
        System.out.println("Pretty Print: "+laptop.prettyPrint());
        System.out.println("Serialize: "+laptop.serialize());

        // Validation demo with polymorphic Result and Exhaustive pattern matching
        switch (laptop.validate()){
            case Ok _ -> System.out.println("Validation passed");
            case Err err -> System.out.println("Validation err "+err);
        }

        // Extension Trait with Composition demo
        // Unlike Rust, you can't augment an existing final class like String.
        // To impl ExtendedString interface you need to compose the String.
        MyExtendedString longString = new MyExtendedString("This is a very long string that needs truncation.");
        System.out.println("Truncated: "+longString.truncate(10));

        // Demonstrate Polymorphic filtering
        List<Product> products = List.of(laptop, keyboard);
        System.out.println("Low Stock Products:");
        List<Product> lowStockProducts = products.stream().filter(p -> p.isLowStock(3)).toList();
        lowStockProducts.forEach(p -> {
            System.out.println(p+" - Quantity: "+p.quantity);
            p.restock(10);
        });
    }
}
```
[top](#Table-Of-Contents)

##### Go Example

In Go, you can create trait-like behaviour using 'mixin' structs to provide default implementations of interfaces.

Limitations
- No extension/augmentation of existing types in another package.
- No trait inheritance.
- No Generic constraints.

```Go
// Go Parametric Polymorphism
package main

import (
	"fmt"
	"unicode"
)

// Interface for Printable trait
type Printable interface {
	// Method that can have a default implementation
	PrettyPrint() string
	// Required method to implement
	Format() string
}

// Interface for Serializable trait
type Serializable interface {
	Serialize() string
	// Default validation method
	Validate() error
}

// Mixin struct to provide default implementations
type PrintableMixin struct{}

// Default implementation of PrettyPrint
func (p PrintableMixin) PrettyPrint() string {
	return "Default Pretty Print"
}

// Validation mixin
type ValidatableMixin struct{}

// Default validation implementation
func (v ValidatableMixin) Validate() error {
	return nil
}

// Custom error type for validation
type ValidationError struct {
	Message string
}

func (e *ValidationError) Error() string {
	return e.Message
}

// Product struct implementing multiple "traits"
type Product struct {
	PrintableMixin
	ValidatableMixin
	Name     string
	Price    float64
	Quantity int
}

// Implementing required Format method
func (p *Product) Format() string {
	return fmt.Sprintf("%s (Price: $%.2f, Quantity: %d)",
		p.Name, p.Price, p.Quantity)
}

// Override PrettyPrint method
func (p *Product) PrettyPrint() string {
	return fmt.Sprintf("[Product: %s]", p.Format())
}

// Custom Serialize method
func (p *Product) Serialize() string {
	return fmt.Sprintf("Product{name=%s,price=%.2f,quantity=%d}",
		p.Name, p.Price, p.Quantity)
}

// Custom Validate method
func (p *Product) Validate() error {
	if p.Price < 0 {
		return &ValidationError{"Price cannot be negative"}
	}
	if p.Quantity < 0 {
		return &ValidationError{"Quantity cannot be negative"}
	}
	return nil
}

// Extension-like functionality using generics (Go 1.18+)
func FilterItems[T any](items []T, predicate func(T) bool) []T {
	var filtered []T
	for _, item := range items {
		if predicate(item) {
			filtered = append(filtered, item)
		}
	}
	return filtered
}

// --------- 1. Wrapper type extension of existing type--------
type ExtendedString string

func (es ExtendedString) Truncate(maxLength int) string {
	s := string(es)
	if len(s) <= maxLength {
		return s
	}
	return s[:maxLength] + "..."
}

// --------- 2. Inteface based extension---------
type Capitializer interface {
	Caps() string
}
type CapitalizeString struct { // no 'implements' needed
	original string
}

// Implicit implementation of Capitializer.Caps()
func (cs CapitalizeString) Caps() string {
	if cs.original == "" {
		return cs.original
	}
	firstChar := []rune(cs.original)[0]
	return string(unicode.ToUpper(firstChar)) + cs.original[len(string(unicode.ToLower(firstChar))):]
}

// --------- 3. Util function is more idiomatic in Go---------
func TruncateUtil(s string, maxLength int) string {
	if len(s) <= maxLength {
		return s
	}
	return s[:maxLength] + "..."
}

// Inventory management "trait"
type InventoryManager interface {
	IsLowStock(threshold int) bool
	Restock(amount int)
}

// Implement InventoryManager for Product
func (p *Product) IsLowStock(threshold int) bool {
	return p.Quantity < threshold
}

func (p *Product) Restock(amount int) {
	p.Quantity += amount
	fmt.Printf("Restocked %s by %d units\n", p.Name, amount)
}

func main() {
	// Create products
	laptop := &Product{
		Name:     "MacBook Pro",
		Price:    1999.99,
		Quantity: 5,
	}
	keyboard := &Product{
		Name:     "Mechanical Keyboard",
		Price:    129.99,
		Quantity: 2,
	}

	// Demonstrate "trait" methods
	fmt.Println("Pretty Print:", laptop.PrettyPrint())
	fmt.Println("Serialized:", laptop.Serialize())

	// Validation demonstration
	if err := laptop.Validate(); err != nil {
		fmt.Println("Validation Error:", err)
	}

	longString := "This is a very long string that needs truncation"

	// -------- Demonstrate 1. Wrapper type extension of existing type --------
	extString := ExtendedString(longString)
	fmt.Println("Truncated:", extString.Truncate(10))

	// -------- Demonstrate 2. Interface-based Extension--------
	capitalized := CapitalizeString{original: longString}
	// You can verify that capitalized type implements Capitializer
	// with the folllowing trick, compiler errors if not:
	var _ Capitializer = capitalized
	fmt.Println("Caps:", capitalized.Caps())

	//  Filtering with generics
	products := []*Product{laptop, keyboard}
	lowStockProducts := FilterItems(products, func(p *Product) bool {
		return p.IsLowStock(3)
	})

	fmt.Println("Low Stock Products:")
	for _, p := range lowStockProducts {
		fmt.Println(p.Name, "- Quantity:", p.Quantity)
		p.Restock(10)
	}
}
```
[top](#Table-Of-Contents)

### Data Orientated Programming vs OOP - Choose Two 

If you can do OOP, you can do DOP: DOP advocates for cleanly separating data from behaviour. Data is modelled using hierarchically nested structs/records/data-objects, and methods that operate on those data are typically extracted into top-level or module/package level functions. DOP tends to adopt more noun orientated naming approach whereas OPP tends to adopt a mix of nouns and verbs.

>[!TIP]
There is no need to extract logic such as data validation and invariant checking into utility functions, this logic should be co-located with your data types, in class/record constructors for example.

### Dependency Rule and Dependency Inversion Principle

The Dependency Rule states that: "Source code dependencies must point only inwards." This is illustrated in the following diagram.  

On the right side of the diagram below ('Crossing Boundaries' and 'DI'), remember the following:
- Interpret the grey 'Flow of control & invocation' arrows as: The side with the arrow-foot calls a method on the arrow-head side. The arrow-foot side must therefore have access to the object on which to call the method.    
- The grey 'Flow of control & invocation' arrows are 'wiggly' because they touch each box in the general flow of control.
- Blue arrows represent UML source code relationships such as 'implements' and 'has a..' for composition.
- Crossing boundaries goes in both ways, from outer to inner and vice-versa. 
- For inner to call outer, use dependency inversion. 

>[!TIP] 
>_"For inner to call outer, use DI -  Make the outer implement methods owned by the inner."_  Uncle DaveM.

![](attachments/Pasted%20image%2020250129143004.png)
[top](#Table-Of-Contents)
![](attachments/Pasted%20image%2020250122162526.png)
 - If you are confused by the direction of the arrows, remember that they point in the direction of source dependencies (imports, includes, composition), not in the direction of data flow. 
 - Structuring code this way does have an overhead - it takes more time and effort.  
 - As mentioned, this would be overkill for scripts. My advice would be to apply the rule pragmatically: Create a partial boundary instead so that it is easier to refactor as the code grows ('Extract Interface' refactoring)

>[!TIP]
>For Pythonistas and Go fans, DIP and DI are less obvious because of their duck typing - there are fewer frameworks compared to statically typed languages. Nonetheless, DIP and DI are still very valid principles to follow in these languages. 

[top](#Table-Of-Contents)
#### A Hearts and Minds Analogy 
 Here's a simple example to help build a mental model ❤️  🧠
- We have a `BigHeart` singleton at the centre of our architecture that implements `Heart`.  Outer layers such as `Legs` can call `Heart.excercise()` to inform the heart we're starting to exercise. To do this, our outer body parts can have a reference to `Heart` without breaking DIP - our outer layers only depend on our inner layer.
- However, what if the Heart needs to broadcast out to our body parts its response to exercise?  We do not want our `Heart` to import specific body parts, that breaks DIP as our inner layer would depend on the outer layer. 
- To resolve this, we define the `HeartBeatReceiever` interface that defines the `heartBeat()` function __within the inner source code package__ i.e. the one that owns `Heart`. 
- All our body parts implement the `HeartBeatReceiver` interface and the corresponding `heartBeat()` method to respond to changes in heart beat . 
- In terms of source code dependencies, our heart does not depend on specific body parts, instead it depends on `HeartBeatReceiver` references. 
- Notice that this enables a flow of control (method invocation) going from outer-to-inner (`BigHeart` calls  `HeartBeatReceiver.heartbeat()`.   
- How does `BigHeart` acquire references to its `HeartBeatReceiver` implementations?     
- This can be done by wiring all our dependencies together into a dependency graph, typically from the main function. If needed, we can use globally declared abstract factory implementations that serve up body part implementations.  
- If you don't like the idea of sprinkling your domain objects with references to abstract factories, this is where Dependency Injection (DI) comes into play. Basically, a DI framework takes the role of wiring together the dependency graph - see IoC.      

![](attachments/Pasted%20image%2020250123161333.png)

Here is our inner `heart` package, notice we have no dependencies on our outer `bodyparts` package - this doesn't break DIP.
```Java
package heart;

import java.util.List;

public class BigHeart implements Heart {
    List<HeartBeatReceiver> heartBeatReceivers;
    private int heartBeat = Heart.defaultRestingHeartBeat;

    public BigHeart(List<HeartBeatReceiver> heartBeatReceivers){
       this.heartBeatReceivers = heartBeatReceivers;
    }

    public int getHeartBeat(){
        return this.heartBeat;
    }

    @Override
    public void exercise() {
       this.heartBeat += 10;
        System.out.println("Heart: responding to exercise - raising pulse, heart beat: "+this.heartBeat);
        for(HeartBeatReceiver receiver : this.heartBeatReceivers){
            receiver.heartBeat();
        }
    }

    @Override
    public void think() {
        this.heartBeat += 2;
        System.out.println("Heart: responding to thinking - raising pulse, heart beat: "+this.heartBeat);
        for(HeartBeatReceiver receiver : this.heartBeatReceivers){
            receiver.heartBeat();
        }
    }
}
```

```Java
package heart;

public interface Heart {
    public static final int defaultRestingHeartBeat = 60;
    public void exercise();
    public void think();
}

```

```Java
package heart;  
  
public interface HeartBeatReceiver {  
    public void heartBeat();  
}
```

```Java
package heart;  
  
import java.util.List;  
  
public class HeartFactory {  
    private static Heart heart;  
  
    public static synchronized Heart create(List<HeartBeatReceiver> bodyParts){  
       if(heart == null){  
           heart = new BigHeart(bodyParts);  
       }  
       return heart;  
    }  

    public static Heart getHeart(){  
        return heart;  
    }
}
```

Here is our outer `bodyparts` package. Notice the src code dependencies on our inner layer - this doesn't break DIP. 
```Java
package bodyparts;  
  
import heart.HeartBeatReceiver;  
  
public class Arms implements HeartBeatReceiver {  
    @Override  
    public void heartBeat() {  
        System.out.println("Arms: hurting");  
    }  
}
```

```Java
package bodyparts;  
  
import heart.HeartBeatReceiver;  
  
public class Brain implements HeartBeatReceiver {  
    @Override  
    public void heartBeat() {  
        System.out.println("Brain: clearing");  
    }  
}
```

```Java
package bodyparts;  
  
import heart.HeartBeatReceiver;  
  
public class Legs implements HeartBeatReceiver {  
      
    public void run(){  
        System.out.println("Legs: running");  
        HeartFactory.getHeart().exercise();  
    }  
      
    @Override  
    public void heartBeat() {  
        System.out.println("Legs: tiring");  
    } 
}
```

Here is our main class/module. Main belongs at the outer edge of our architecture and depends on our inner layers. Without an IoC container, this is where you 'wire-together' the application's dependency graph. If you use an IoC container, the container does this for you - hence we're giving control to the IoC. 

```Java
import bodyparts.Arms;
import bodyparts.Brain;
import bodyparts.Legs;
import heart.Heart;
import heart.HeartBeatReceiver;
import heart.HeartFactory;

import java.util.List;

public class Main {

    public static void main(String[] args) {
        Legs legs = new Legs();
        Arms arms = new Arms();
        Brain brain = new Brain();
        List<HeartBeatReceiver> bodyParts = List.of(legs, arms, brain);
        Heart heart = HeartFactory.create(bodyParts);
        legs.run();
        System.out.println("\nMain: Thinking");
        heart.think();
    }
}
```

The application prints the following: 
```
Legs: Running
Heart: responding to exercise - raising pulse, heart beat: 70
Legs: tiring
Arms: hurting
Brain: clearing

Main: Thinking
Heart: responding to thinking - raising pulse, heart beat: 72
Legs: tiring
Arms: hurting
Brain: clearing
```


### Dependency Injection and Inversion of Control to Implement the Dependency Rule and DI 

Basically, this means that your application code does not itself create instances of business objects directly. Instead, these objects are created separately by 'wiring logic' that sits outside of your immediate business/domain code. As a result, business and domain objects are then automatically injected into other business/domain objects. Injection occurs via class-constructors for required dependencies, or setter methods for optional dependencies. The wiring code can be implemented manually by passing dependencies to objects.  This typically occurs: from a main module/function, via the *Factory Pattern*, or using *Inversion of Control* containers such as [Spring.io](https://stfc365.sharepoint.com/sites/HartreeRSEPublic/Shared%20Documents/General/spring.io) that manage the wiring for you. 

For the most part, the lifetime of a class is typically either singleton-scoped a.k.a., ‘application scoped’, where a single instance is created and managed (which means it must be thread-safe), or ‘prototype-scoped,’ where a new instance is always created & injected. However, there are several other specialised lifetimes such as ‘session-scope’ or 'transaction-scope' depending on your requirement.

So, what is the benefit of IoC? 
- Separation of Concerns: First, the ‘wiring logic’ is cleanly separated from your domain logic; wiring logic resides in Factory classes or is managed by the IoC container.
- Decreased Code Coupling: This really is an excellent approach for decreasing _code coupling_ if you use abstractions/interfaces. Dependent code only needs to know about higher-level abstractions, not concrete details. This really helps reduce complexity.
- Late Binding: By not depending on concrete classes, it creates the opportunity for IoC to read in class libraries that have been dynamically dropped into your server at runtime without having to make any changes to your logic (see late-binding).
- Advanced Life Cycle Management: The wiring code in your IoC container or Factory can be used to manage the *life cycle* of your dependencies which enables several possible optimisations and actions. For example: 
  - 'Just in time' creation of objects enables late-binding for dynamic use-cases such as dropping in new libraries without server re-start, 
  - Objects can be cached within object pools which helps reduce potentially expensive object creation for increased performance. 
  - Managing the life cycle of objects outside of your injected classes provides a 'point-cut' for custom actions. For example, when an object is returned to the pool, you can fire an event, for example.
  - Object destruction can be handled under an external managed process.
- More effective testing: You can mock different dependencies/classes and inject them into your objects as needed to test different scenarios. A very simple example from Dave Farley’s ‘Modern Software Engineering’ book is given below:

[top](#Table-Of-Contents)

```Java
// Two versions of Car and BetterCar, 
// after Dave Farley's Modern Software Engineering Book. 
// BetterCar has constructor injected engine which is easier to test.

class Car {
    private final Engine engine = new PetrolEngine();
    
    public void start() {
        applyBrakes();
        putIntoPark();
        this.engine.start();
    }

    private void applyBrakes(){ /*...*/ }
    private void putIntoPark() { /*...*/ }
}

class BetterCar {
    private final Engine engine; 

    public BetterCar(Engine engine) { 
        this.engine = engine;
    } 

    public void start() {
        applyBrakes();
        putIntoPark();
        this.engine.start();
    }

    private void applyBrakes(){ /*...*/ }
    private void putIntoPark() { /*...*/ }
}

```

For the `Car` class, unless we decide to break encapsulation and make `engine` public, you can’t test the engine separately.  Our `BetterCar` allows you to mock or create a different engine implementation and test that separately as shown below:

```Java
@Test
public void shouldStartBetterCarEngine() {
    FakeEngine engine = new FakeEngine();
    BetterCar car = new BetterCar(engine);
    car.start();
    assertTrue(engine.startedSuccessfully());
}
```

[top](#Table-Of-Contents)

### Circular Dependencies via Setters and Lazy Initialisation 

In the example above, lets assume we remove the interfaces so that we deal just with concrete types, we could then define a circular dependency; body part implementations depend on the heart implementation and vice-versa.  This raises the question, our heart implementation needs to be given a list of concrete body parts, and our body parts need to be given a reference to our heart. If we use constructors for dependency injection, we can't create create one without creating the other because our dependency graph has a circular dependency, it is not acyclic.  So, assuming we do need a circular dependency, how can this be done? There are a few ways: 
1) __Remove circular dependencies__: Use Dependency Inversion. I also agree with most of what [Rob Pike](https://github.com/golang/go/issues/30247) recommends in his justification for not supporting circular dependencies in Go, but I also think accommodating circular dependencies sometimes does crop up in certain use-cases, most commonly at the class level within a single layer.
2) __Setter Injection__: Body part implementations could receive a heart through a setter method rather than through their constructors. This enables us to create our body parts first, our heart can be created second, and third we pass our heart to each body part. This is ok in some scenarios if the dependency is optional. However, the heart is required and we do not want to create a body part in a partially complete state. 
3) __Lazy Initialisation via the Static Method Pattern__: Body Parts can request a reference to a heart through a static factory method. This allows us to create body parts and heart independently; the heart is created lazily the first time a reference is requested. Static methods are sometimes considered as being dirty because they can break encapsulation, create tight coupling between classes, and make code harder to test and maintain. https://www.baeldung.com/cs/factory-method-vs-factory-vs-abstract-factory
4) __Lazy Initialisation via Static Factory Pattern and Abstract Factory__: Creation of objects and aggregates of objects is managed by a factory service. 
5) __Lazy Initialisation via Lazy metadata/annotations__: if you are using an Inversion of Control container for dependency injection, the IoC container likely provides annotations to indicate the order of initialisation. For example, Spring provides the `@Lazy` annotation that can be used on dependencies declared on the consumer side to delay their creation until they are needed. This can be very effective, you don't then introduce static methods which some consider as being a dirty approach.  

```Java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

@Component
public class BeanA {
    private BeanB beanB;

    @Autowired
    public BeanA(@Lazy BeanB beanB) {
        this.beanB = beanB;
    }
}
```

>[!TIP]
One situation where I find separate Factory classes appropriate is for returning an aggregate (see DDD) when the final object you are creating relies on several other objects as dependencies. 
### Dynamic Late Binding vs Static Binding 
This is a big topic, but as ever, there are trade-offs between the different approaches which ultimately depends on your use-case:

- *Dynamic/late binding:* Allows new code to be deployed without having to re-build and re-start your runtime. This literally means that your application code can evolve over time without re-building and re-starting your application. To do this, you require a dynamic language and runtime such as languages built on the JVM, JS, C# Python and Ruby. A classic example of a dynamic application is Minecraft where player-made mods or custom maps and APIs can be added to a running Minecraft realm. Another example where late binding is for applications that have plugins, this is common in business applications that need to be easily extended such as adding new file parsers or algorithms without having to re-build and re-start the app server. Typically, new functionalities are loaded using *class loaders* through special pluggable library files e.g., `.jar` files containing *dynamic proxies* and implementations of *Service Provider Interfaces* (SPIs). For these types of use-case, late binding is very powerful, but in my opinion, for the majority of applications, it is overkill. Late binding is commonly implemented using a technique called *reflection* which is not as performant as static binding because code needs to be introspected in order to invoke the new functionality. Polymorphism also allows method overriding for new sub-types to be loaded at runtime using *dynamic dispatch*. A classic example is dynamically loaded component pallets in a CAD application containing new object sub-types.

[top](#Table-Of-Contents)

Classic examples of dynamic applications include: 
  - *Game Engines* like Unity and Unreal Engine use dynamic binding to load and unload game assets, scripts, and plugins at runtime which enables modular game development and creation of customizable games.
  - *Web browsers* that interpret and execute JavaScript code dynamically to enable web sites to create interactive web pages.
  - *AI and Machine Learning Frameworks* often use dynamic binding to load and execute different models and algorithms at runtime, allowing for experimentation and customization 
  - *Virtual machines* like the JVM and the .NET CLR (Common Language Runtime) use dynamic binding to load and execute classes at runtime.
  - *IDEs* like Intellij IDEA use dynamic binding for their plugins.
  - *Frameworks* like Spring often rely on dynamic binding to allow developers to extend the framework's behaviour without modifying its core code. For example, you can create custom components and inject them into the framework's configuration.
    - DI/IoC containers have changed a lot recently. In the past, they have largely been built for dynamic binding using reflection, but these days you can choose the IoC implementation depending on your requirements, dynamic or static.  
  - *Security applications* for applying patches and updates without restarting. 
  - *Operating systems* like Windows and Linux use dynamic loading to load device drivers and system libraries at runtime. 

- *Static binding:* If you do not need to modify runtime behaviour with plugins or highly dynamic late binding, for the majority of simpler use cases choose static binding for more performant Ahead of Time (AOT) compilation. Late binding is generally more secure considering the additional potential to load malicious code. 

[top](#Table-Of-Contents)

### It Should Not be Possible to Create an Object in an Invalid State

Nuff said. Just to be clear, you should not be able to construct an object in an invalid state. There are several ways to prevent invalid object creation, including the following approaches (I'm sure there are others too): 

#### Throwing Exceptions from Constructors

For example, you could throw an `IllegalArgumentException` runtime exception from within a constructor. However, remember that exceptions should be reserved for truly exceptional circumstances and often it is better to model invalid states explicitly in your type system as potential domain errors. In this case, consider the following approaches.  

#### Use a Smart Constructor or Factory to Return a Smarter Return Type

In the example below, we use a Kotlin smart constructor to hide the primary constructor and model an invalid author name explicitly in our type system. This way, we create an `Author` object using a familiar constructor call syntax and is clear that a potential outcome is an `InvalidAuthorName`. You can of course apply the same approach in the standard factory pattern. 

```Kotlin
object InvalidAuthorName

data class Author private constructor(val name: String) {
  companion object {
    operator fun invoke(name: String): Either<InvalidAuthorName, Author> = TODO()
  }
}

val authorResult = Author('Homer')
var? author = when (authorResult) {
  InvalidAuthorName -> TODO() // return early, throw runtime ex, return null 
                              // (Kotlin models null explicitly  for us with var? syntax)
  Author -> authorResult.value
} 
```

#### Use the Builder Pattern to Check Complex Invariants Before Building the Object

See the builder pattern. The final `build()` function should be used to check complex invariants and can return a smarter return type such as an `Either` or an ADT. An invariant is a condition that must hold true typically across multiple state variables.

### Know Some Design Patterns

There might be a tried & tested design pattern for the problem you’re tackling. Some patterns are probably overkill, but some genuinely useful patterns include Factory, DTO, Observer, Strategy, Singleton, Repository, Stateless Façade, Visitor. Have a look at the recommended texts in the appendix. Gang of Four (GoF) is kinda regarded as old school these days.

![](attachments/Pasted%20image%2020240611094028.png)

[top](#Table-Of-Contents)

#### The Strategy Pattern Example

This pattern abstracts logic behind a common abstraction such as a SAM interface (Single Abstract Method interface) so that an implementation can be **chosen at runtime**. This makes the code more flexible and reusable. In the Kotlin example below taken from [Dave Leeds](https://www.youtube.com/watch?v=-Ak44LFwlwI&t=64s), we use validation as an example, where any of the validators can be passed at runtime to the FormField class.

![](attachments/Pasted%20image%2020241016180911.png)

[top](#Table-Of-Contents)

Here are two more Kotlin examples that are more idiomatic which reduce boilerplate, again from Dave Leeds:

![](attachments/Pasted%20image%2020240905162859.png)

An even more concise example:

![](attachments/Pasted%20image%2020240905163103.png)

Note you can use an extension function to easily create an optional version:

![](attachments/Pasted%20image%2020240906135416.png)

At the call site:

![](attachments/Pasted%20image%2020240906135400.png)

[top](#Table-Of-Contents)

#### The Visitor Pattern

The visitor pattern is used to separate business logic from objects on which they operate. Typically, objects define an accept method then call method(s) on the accepted visitor. The calling object is typically passed to the visitor as an argument so the visitor can access the object's public state, as in the pseudo code: `accept(Visitor v) { v.visitDoLogic(this); }`.   New logic can easily be added to the visitor's `visitDoLogic(callerObj)` without having to update the calling objects which illustrates an example of the open closed principle in SOLID.   This pattern uses a double-dispatch logic: first an object's `accept(Visitor)` method is invoked, then the visitor's `visitDoLogic(obj)` method second.

The visitor pattern is typically invoked for large cascading / nested object trees; an `accept` method can pass the visitor instance to all its member objects that also define an accept method, for example:

```c#
public class Addition : Expression {
  public Addidtion(Expression left, Expression right){
    Left = left;
    Right = right;
  }
  public override void Accept(Visitor v) {
    Left.accept(v);
    Right.accept(v);
    v.vist(this);
  }
 // get values etc elided 
}

// invoking code would create a Visitor implementation and invoke the double dispatch logic by calling `Addition.Accept(visitor);`
```

[top](#Table-Of-Contents)

Languages implement the visitor differently. For strongly typed polymorphic languages that support method overloading (Java, C#, Kotlin), interfaces can be used simplify the double dispatch logic where `accept` and `visit` methods can be overloaded using different argument types.  Languages that do not support polymorphic overrides e.g., Go and Python, typically need to define different visit-method names e.g.

```Go
type Visitor interface {
 visitWheel(wheel Wheel) string
 visitEngine(engine Engine) string
 visitBody(body Body) string
 visitCar(car Car) string
}
```

[top](#Table-Of-Contents)

#### Builder Pattern for More Complex Object Creation Scenarios

Builders are especially useful if the dependencies of your class have complex invariants. Basically, this means that if you class can only be constructed with a particularly complex combination of dependencies such as ‘my object requires A and B and either C, D, or E and F, but never G if D is present’ (I’m sure you get the idea), then the Builder pattern can help you. How to implement this in your chosen language varies of course e.g., in Go check out the [Functional Options Pattern](https://www.youtube.com/watch?v=MDy7JQN5MN4) where you pass functions to modify the state of a struct. This is a nicely explained example, but it has some issues, first it lacks a `build()` function that is typically used to validate invariants before returning a valid 'built' instance. Second, having a bunch of standalone functions in the Functional Options pattern gives poor discoverability, it can make more sense to use a Builder type bunch of setter functions to set invariants - this means you can easily discover and chain setters using dot notation and code-completion e.g. with pseudo code: 

```
configOps = NewConfigOptionsBuilder().id("someId").maxConnections(10).prefix("somePrefix").build();
```

e.g. [builder pattern in Golang]( https://dev.to/kittipat1413/understanding-the-builder-pattern-in-go-gp9) 

[top](#Table-Of-Contents)

### Information Hiding

Your first instinct should be to make a method/member/variable private first, then increase visibility as required, not the other way around.

### Keep it Simple Stupid KISS

Bugs can't hide in simplicity. 

### DRY Do not Repeat Yourself

Duplicating chunks of code is odorous - don’t do it.

### YAGNI You Are not Going to Need It

Following Agile processes (i.e., ‘Feedback Driven Development’) should trap and prevent unnecessary code.

### Comment in line As You Go

You don’t retrospectively comment your code, you just don’t. Using sensible names should prevent long-winded doc strings.  Use xDoc tools e.g., PyDoc, JavaDoc, xDoc etc. Document the _intent_ of the function/class, not the implementation details.

[top](#Table-Of-Contents)

### The Boy Scout Rule

Leave code in a better state than you found it & don’t comment bad code, re-write it with good descriptive names.

### Principal of Least Knowledge and Train Wrecks - The Law of Demeter

🚃💥🚃💥🚃💥🚃  

A module should not know about the innards of the objects it manipulates. Important: by ‘objects’, I mean objects that have state and methods that operate on that state.  It is quite normal to have deeply nested data objects/structs/records call methods to access data - for these types of data carrying objects, the Law does not apply. [https://en.wikipedia.org/wiki/Law_of_Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter)

>[!TIP] 
> Method `f` of class `C` should only call the methods on these:
>- `C`
>- An object created by `f`
>- An object passed as an argument to `f`
>- An object held in an instance variable of `C`
>
> `f` should not invoke methods of any other objects returned by any of these approaches.  In other words, talk to friends, not to strangers. 

[top](#Table-Of-Contents)

### FP vs OOP - Choose Two

To quote Eric Evans, an expert in both OOP and Functional paradigms and of 'Domain Driven Design' book fame: "At times, I found FP an awkward fit. The problem would have fit OOP better. I'm happy that it is easier than it used to be to move between both those ways of thinking." 

I completely agree with Eric - if the language permits, combining functional approaches with OOP is powerful in the right scenario. In fact, modern languages are more of a hybrid mix of OOP, Procedural & FP e.g. Rust, Kotlin, modern Java (others languages too). Hybrid approaches borrow concepts from FP such as ADTs, default immutability, functional composition such as `map` `filter` `collect`. 

For the majority of developers, myself included, I also believe that adopting a pure functional language is a stretch - their popularity are still low representing ~5% of mind share according to IEEE, Tiobe.  I think the primary reason is that people just comprehend the world more readily in terms of objects, state and procedures, compared to purely functional/mathematical ways of thinking such as recursion and 'higher order functions'.  To boil it down further, basically loops are difficult or even unavailable in pure FP, and I think allowing some interior mutability is often a small price to pay for simplicity.      

![](attachments/Pasted%20image%2020240611091943.png)

Therefore, if your language, my recommendations are to mix some functional concepts when appropriate: 

> [!TIP]
>  * Use a naming convention to identify pure functions, see using 'Calculations to limit side effects'
>  * Push out side effects to the out boundaries of your code (see the Dependency Rule / Bullseye) so they become 'intended effects’ and not nasty interleaved ‘side effects’.
> * Aim for a core of pure functions.
> * Aim for immutability as your default.

[Well worth a watch](https://www.youtube.com/watch?v=HSk5fdKbd3o&t=543s)

[top](#Table-Of-Contents)

#### Be Careful Not to Pollute Pure Functions with Hidden Mutable State

Pure functions need to remain pure; you really don’t want to pollute your pure functions with hidden shared mutable state across threads. Consider the following example - one is broken, the other is ok, the difference is subtle.  So, while combing FN + OOP is powerful, be very careful.

![](attachments/Pasted%20image%2020240611094242.png)

`ParallelStream` will split work across a thread pool, this means the list, which is not atomic and is our external mutable state, is subject to a whole host of complex threading issues (overwrites, ghost-reads, race conditions etc). Replacing the `forEach` with a functional ‘reducer’ operation (e.g., `toList()`) and converting the call chain from a statement to an expression solves the issue - there are no statements in _pure_ functional code.

[top](#Table-Of-Contents)

#### Make Private your Default Class Level Visibility

Modern languages make class members private by default, at the individual class level. Older languages like Java make member variables private at the wider package level by default, which is too visible  in my opinion.   Recommendation is to make members private at the class level. 

[top](#Table-Of-Contents)

#### Make Immutability your Default

- Global Mutable State is evil and will eventually cause you problems.
- Modern languages are immutable by default, for example, in Rust and Kotlin, you need to specifically ‘opt into’ mutable variables using special keywords such as ‘mut’ and ‘val’ (immutable) instead of ‘var’ (mutable).

[top](#Table-Of-Contents)

#### Interior Mutability

When mutability is necessary, try to encapsulate it within a function so any mutable state is not leaked. This is known as ‘Interior Mutability’.  To do this, you’ll likely need to take defensive copies of the input parameters to reduce the risk of side effects.

[top](#Table-Of-Contents)

#### Use Calculations Where Possible to Limit Side Effects

Calculations or ‘pure functions’ have no side effects and are ‘idempotent’. This means given the same input arguments, idempotent functions will return the same value regardless of _when_ you call them (incidentally, this means you can cache the results of expensive calls in a lookup table, for example).  Operations may have side effects such as updating a database, writing a file to disk, calling a remote service, even printing to the console is a side effect (maybe another process is reading your stdout/err?). Operations return values may change depending on _when_ you call them. For example, consider calling a travel service with the same function parameters – results will probably vary depending on the time of year or time of day. One approach to help make code that depends on randomness (e.g., a random number is required), is to provide a seed value, and make that part of the external API which allows you to test using the same seed values.

[top](#Table-Of-Contents)

#### Separate Operations from Calculations

See prior bullet. Functions should either do something such as create side effects (operations) or provide an answer to something such as returning a result from a stateless calculation. Try to separate functions that have side-effects from pure functions (aka calculations) using a naming convention. Try not to do both in a single function.  In some languages you can be explicit– e.g., in Kotlin, a common convention is to reserve single expression functions only for calculations – you can quickly/easily see this in the first line of the expression function signature – no need to understand the function body for side effects. Nevertheless, unless you are using a pure functional language, this is still only a convention.

[top](#Table-Of-Contents)

### Data Orientated Programming with Algebraic Data Types - ADTs

ADTs combine ‘Product Types’ for modelling aggregation such as a C/Golang/Rust ‘structs’ or Java's Record type with ‘Sum Types’ for modelling choice, also known as ‘Union Types’ or ‘Tagged Unions’. This simple combination of aggregation and choice is deceptively powerful and shows up in many programming languages to model domains, return types and function arguments:

- Product Types are great for modelling aggregation, and include immutable data classes such as records, data objects, and structs. They are called ‘Product Types’ because their state ‘when considered as a whole’ is the Cartesian product of their data.

- Sum Types can be used to represent choice and are polymorphic - an abstraction such as a marker/type interface with a fixed set of implementing subtypes (e.g., ‘sealed’ classes or interfaces in Kotlin/Java, ‘enum’ in Rust, ‘Union’ types in Python). They are called Sum Types because the set of possible types is the sum (union) of the total allowable set.

[top](#Table-Of-Contents)

In some modern languages (e.g Rust, modern Java, others), ADTs can be efficiently processed using de-structuring and exhaustive pattern matching with `when` & `switch` statements. Exhaustive matching means the compiler will generate a compilation error if not all types are explicitly handled. As highlighted by Gavin Bierman in his Devoxx talk, you can spot many 'lightly disguised abstractions such as JSON' and model them as ADTs as shown in the following diagram: 

![](attachments/Pasted%20image%2020241103131635.png)

From Gavin Bierman's Devoxx talk, Java Language Futures: https://www.youtube.com/watch?v=NNPN5tvjzqA&t  Using the sealed interface, it would be simple to permit a range of additional custom types that implement `JsonValue` such as `MyCustomString` and `ThingArray` for example.  

[top](#Table-Of-Contents)

### Error Handling

#### Error Handling - Four Types of Problems

1. Unrecoverable problems: Is the error recoverable? If not, then let the program crash/panic/throw (runtime exception). For example, a `FileNotFoundException` should crash if that file is the application's mandatory config file - you can't continue without it, but for a file browser application, probably not.

2. Recoverable problems: For example, if a remote service is temporarily unavailable, you could introduce a retry before showing an error to the user.

3. Errors that need to propagate to the user:  An error-as-value would be suitable if you are building a file-explorer GUI - you don’t want your program to crash if a file gets deleted by another process. In this scenario use a value-error or catch the exception and convey a sensible message to the user.

4. Programming mistakes:  Let the program crash/panic/throw (runtime exception), you’ll be motivated to fix the problem quickly. 

[top](#Table-Of-Contents)

#### Error Handling - Fail Early

> [!TIP]
> Guard clauses should be defined early - do not define lengthy conditional success blocks when you have can have short fail blocks defined early.  

```Kotlin
fun badGuardClauseExample(val arg1)
    if(valid(arg1)){ 
        ...success path...
    } else {
       ... error handling...
    }  
}

// better
fun betterGuardClauseExample(val arg1)
    if(notValid(arg1)){  
       // ... error handling ...  
    }  
    ... success path...
}
```

#### Error Handling - Be defensive at application boundaries, not within your inner domain logic 

> [!TIP]
> - Polluting your 'inner' business logic with defensive checks is unnecessary and can obfuscate genuine bugs. 
> - Validate at the edge of your application:  Postel's Law really only applies at the edge of your application, at the boundary when receiving incoming data: "be liberal in what you accept and conservative in what you return."  
> - Being defensive when using 3rd party libs is ok.  

Note, the application boundaries are illustrated in the application bullseye diagram, and in the classic 'Hexagonal Architecture'.  

#### Error Handling - Model the Absence of Values Explicitly

> [!TIP]
>If a value can legitimately have no value, ensure safe nullability by modelling null explicitly in your type system (if not already handled by your language) e.g. use approaches such as known zero values, Optionals, ADTs, and monads. 

Handling null depends on the language and programming style you are using:

- Nullable languages (C/C++/Java): Dereferencing a null pointer causes bad things to happen. This is known as ‘the billion-dollar mistake’ coined by Tony Hoare, in 1965. In your code, be sure to make it clear when null is meant to represent the ‘absence of value’ (e.g., with @Nullable annotations for example). At the boundary between layers of your code and when using a 3rd party library for example, it is ok to be ‘defensive’ and check for nulls.

- Many argue null is an acceptable way to represent the absence of value, it’s just a fact and is too fundamental in many layers.  They argue the real billion-dollar mistake is not null itself, but in the failure of the language to do type-safe handling of null.

- Some languages e.g., Kotlin, Rust & Python have ‘safe nullability’ baked into their type-systems e.g., None to mean no value and optional ‘?’ on variables (‘var?’) to indicate this variable might be null.

- Functional languages commonly use `Either` monads to wrap errors and `Optional` for the absence of value. With these monads, the programmer is forced to handle the occurrence of no value or an error, typically using a pattern-matching style of syntax which means errors can’t be ignored, mistakenly or otherwise.

- Various modern languages use Algebraic Data Types (an extension of the [Special Case pattern](https://martinfowler.com/eaaCatalog/specialCase.html](https://martinfowler.com/eaaCatalog/specialCase.html)) and return types that wrap either a successful result or an error (Go, Rust, Kotlin, modern Java).

- ADTs combine ‘Sum Types’ and ‘Product Types’ and are excellent for representing multiple special cases, including multiple error states.

[top](#Table-Of-Contents)
##### Error Handling - Do Not Initialise with Null or Return Null

> [!TIP]
> Don't initialise struct values with null or return null from functions.
#### Error Handling - Exceptions vs Errors-as-Values

Errors as values vs exceptions is a hotly debated topic in programming communities. There are pros and cons to each approach. 

Errors-as-Values
```go
package main

import (
    "errors"
    "fmt"
)

func f(arg int) (int, error) {
    if arg == 42 {
        return -1, errors.New("can't work with 42")
    }
    return arg, nil
}

func main() {
    for _, i := range []int{7, 42} {
        if r, e := f(i); e != nil {
            fmt.Println("f failed:", e)
        } else {
            fmt.Println("f worked:", r)
        }
    }
}
```

Throw runtime exception:
```Java
import java.util.Arrays;  
import java.util.List;  
  
public class Main {  
    public static int f(int arg){  
        if(arg == 42) {  
            throw new IllegalArgumentException("can't work with 42");  
        }  
        return arg;  
    }  
  
    public static void main(String[] args) {  
        List<Integer> list = Arrays.asList(7, 42);  
        for(Integer i : list){  
            try {  
                int r = Main.f(i);  
                System.out.println("f worked "+r);  
            }catch(IllegalArgumentException ex){  
                System.out.println("f failed");  
            }  
        }  
    }  
}
```
##### Proponents of errors-as-values

- Fans of errors-as-values argue that functions should return either a success value OR a failure value for known business errors. In doing this, the potential for failure is made explicit in a function signature.  I agree - it is is commonly regarded as the more reliable approach to handling known business errors because you are explicitly forced to handle errors immediately, typically using a conditional to test for error or success. This ensures error handling is not an afterthought. 
- Supporters also argue that there is less uncertainty compared to throwing exceptions because it can be challenging to determine all the exception types that can be thrown by a deep call stack. Also recognise that unhandled unchecked exceptions do not create compilation errors, meaning the compiler can't help you discover all of the different types of unchecked exception that could be thrown. You often need to dig and read all the docs.
- Another issue of a specific type of exception known as a 'checked' exception is that they prevent functional composition. This is because the compiler forces you to handle checked exceptions wherever they can be thrown, but they are not considered as part of a function's return signature and type system. Instead, exceptions invoke orthogonal flows that 'break out' of your regular functional flow. Checked exceptions therefore breaks 'referential transparency' (see discussion below on Error Monads such as `Either` & `Validated`). Checked exceptions are generally not recommended these days, except for certain special use-cases where they still have their supporters.

[top](#Table-Of-Contents)
##### Proponents of exceptions

- Fans of exceptions argue that by forcing you to interleave error checking at function call sites throughout your code obscures the code's happy path and readability.  
- Exception fans also argue that exceptions centralise your error handling code which gives a clean separation of concerns.
- For low-level code, exceptions are largely considered an effective strategy for surfacing underlying issues such as low level operating system issues which may be mistakenly obscured by the errors-as-values pattern (although the same could be said by mindlessly catching all exceptions).
- When used correctly and with discipline, exceptions can also be more performant than interleaved error-value checking. This is because languages like C++ and Java have 'zero cost exception handling.' I think this is a misleading term, what it actually means is 'zero cost to the happy path code provided no exceptions are thrown.' Assuming no exceptions are thrown, quite simply, there is less for your code to do as there are no interleaved conditional error checks. While any performance hit from interleaved result checking is likely to be marginal for the majority of use-cases, it may become more pronounced in deeply nested code or tight compute loops. However, this can be mitigated with good code structuring by moving error checks out of and before any performance critical-sections.

![](attachments/Pasted%20image%2020250125114743.png)


> [!TIP]
> Quite simply: use errors-as-values to model known business errors, and runtime exceptions only for genuine exceptional conditions and programming bugs. 

> [!TIP]
> `try/catch` and `panic/recover` are very different strategies, a key difference is the resulting control flow after they are triggered.

In a `try/catch/finally` block, unless you re-throw or return from within the catch or finally block, code coming after the `try/catch/finally` block *will still execute*. This does not happen with `panic/recover` - a function that is aborted via panic begins to unwind the stack, running deferred blocks/functions as it encounters them (in Go, this is the only place recovery takes affect, although use of recover is not widespread in Go and `panic` is typically used to end a program). Thus, panic/recover is very different to try/catch stemming out of the fact that it is built around deferred logic as a recovery mechanism (e.g. Go & Zig).

[top](#Table-Of-Contents)

Whether to use exceptions has profound implications on your API design and performance, be aware of the issues highlighted above. Some modern languages, e.g. Mojo, go as far as trying to address the choice for you by compiling exception handling code under-the-hood to use errors-as-values. I think the aim is to allow you cleanly separate the happy path from exception handling code (clean separate of concerns). At the time of writing, it is too early to tell if this is a successful strategy.

Of course, choice between exceptions or errors-as-values depends on the language and environment - you don't get exceptions support on every architecture and platform. The result pattern is much more flexible especially on embedded systems.

##### Can I use both styles in a hybrid approach

- Yes, depending on your language of choice and what is considered idiomatic. Some modern languages support both approaches. For example, to support interoperability with Java, the Kotlin language supports unchecked exceptions as well as its own `Result` type which is intended for low-level code rather than for modelling business errors. For modelling business errors, they recommend using sealed class hierarchies that introduce exhaustive pattern matching to handle errors (see discussion on data oriented programming).

- At the time of writing, a dedicated union type for capturing a result OR one or more errors is on the [Kotlin roadmap](https://www.youtube.com/watch?v=B-DoVr12fK0).

- Languages may also support more advanced error handling strategies. For example, the Kotlin Arrow2 library simplifies the use of OOP and Functional error handling within the same code base (Functional vs OOP? - choose both). For example, lower level code or existing code can apply `try/catch/finally` blocks for localised exception handling and recovery if needed, while higher level calling code can provide a wrapping `error context` that can be used at the boundary; Rather than throwing exceptions at the boundary between different layers of code, exceptions can be _raised_ into the higher level error context. Raising rather than (re)throwing this allows the functions that raise to be composed within functional compositional call chains because raising does not break referential transparency. In the top layer of your code, such as in a top-level service facade or global error handler in a webapp, you would then need to handle the exceptions raised within the error context, such as performing a transaction roll back or performing a retry.  For a great presentation with examples, see this great talk from Simon Vergauwen from [Kotlin Conf 2023](https://youtu.be/JcFEI8_af3g?si=vH5OG86JTQWFrGnw) (note that context receivers as used in the talk will be replaced by context parameters in the future).

[top](#Table-Of-Contents)

#### Error Handling - Exceptions Should Not be Used for Flow Control - Exceptional Does Not Mean Conditional

Passing around a deeply nested stack trace within conditional and control logic is very expensive, don't do it. Instead, model your (known) business errors as values (no need to pass around exceptions), and leave exceptions for coding errors and exceptional situations. If you want control flow logic that says "if success do this..., but if an error occurs then do this..." then use the result pattern.

[top](#Table-Of-Contents)

#### Error Handling - Only use Exceptions for Exceptional Situations Such As Coding Errors and Unexpected Errors 

For example, an invalid object posted to your API is not exceptional, this should be handled as a potential business error. In the situation where some code throws an exception such as a parse error, catch it locally, extract the useful information, and return an error-value. In general, the result-as-value pattern is appropriate where the problem is the fault of the caller and not a programming mistake e.g., invalid input / form data.

[top](#Table-Of-Contents)

#### Error Handling - Provide Relevant Exceptions for the Abstraction Layer

If you use exceptions (not all languages have exceptions e.g., Rust, Go), define Exceptions in terms of a caller’s needs and wrap 3rd party library APIs including their exceptions. Often, only a few custom exception classes are needed for a particular area of code.

[top](#Table-Of-Contents)

#### Error Handling - Bubble Exceptions Upwards or Trap at Source

Generally, pushing genuine runtime exception handling code (for unexpected problems) up to the ‘outer layers’ of your code toward the boundaries is usually a good approach. It also helps cleanly separate the ‘happy path’ from interleaving error handling code.  However, this is not a hard rule, in some situations you may need to try/catch/finally at the source of the error to take important corrective actions such as closing an IO resource or rolling-back a DB transaction.

[top](#Table-Of-Contents)

#### Error Handling - Model Exceptions as Values with Algebraic Data Types 

With ADTs, for any single function, you can replace any thrown exceptions and return values using a single generic abstract data type. Using a sealed interface, all possible success and error variations can then be modelled using ad-hoc polymorphism. This means the _abstract_ data type becomes an _algebraic_ data type (ADT), also known as a 'nominal' or  'named' union type (an ADT provides the combination of aggregation *and* choice to model all possible variants). The ADT replaces exceptions with 'errors-as-values,' and multiple optional success types, if required. 

This is super-powerful because you can add new success and/or error/exception return types through polymorphism, and also intentionally restrict all calling clients to a single permissible enum set. This is invaluable for developers of libraries for example where you explicitly want to limit the return types of your library functions and prevent clients overriding with their own implementations.  

[top](#Table-Of-Contents)

To process the function's abstract return type with very little boilerplate, exhaustive pattern matching with switch ensures all possible variants are handled - the compiler will produce an error if any are unhandled. There is a lot to unpack here, but the example given below from Gavin Bierman clearly demonstrates this approach using modern Java (2024). The use of ADTs with pattern matching is being coined in the Java community as 'Data Orientated Programming,' and can be applied for modelling any data type hierarchies such as converting JSON to Java types, but Java certainly wasn't the first language to implement this approach. I suspect that this approach will become very popular in the Java community in the future, moving away from exceptions in higher level application code (note, as discussed above, exceptions will still have their place in lower level library and framework code). 

```java
public class Main {
    public static <V> void main(String[] args) {

        // Switch uses exhaustive pattern matching and deconstruction. 
        // A compile time error is generated if not all variations are handled.
        Result<V> result = updatedLegacyFunction(4L);
        switch (result) {
            case Failure<V>(Throwable cause) -> println("Throwable "+cause);
            case Interrupted<V> v -> println("TODO");
            case Success<V> v  -> println("val is "+v);
            case Timeout<V> v -> println("TODO");
        }
 .  } 

    // legacy function that throws exceptions
    static long legacyFunction(long timeout)
            throws InterruptedException, ExecutionException, TimeoutException {
       // ...elided... 
    }

    // can be re-written to return an ADT
    static <V> Result<V> updatedLegacyFunction(long timeout){
        if (timeout < 5) return (Result<V>) new Success<>("All good");
        return new Failure<>(new TimeoutException());
    }
}

// Result<V> is an Algebraic Data Type.  
// ADTs combine power of union/sum types for modelling choice with 
// product types to model custom wrapped errors. 
sealed interface Result<V> permits Success, Failure, Timeout, Interrupted { }
record Success<V>(V result) implements Result<V> {}
record Failure<V>(Throwable result) implements Result<V> {}
record Timeout<V>() implements Result<V> {}
record Interrupted<V>() implements Result<V> {}
```

Using ADTs to model better return types. After [Gavin Bierman's Devoxx talk, Java Language Futures](https://www.youtube.com/watch?v=NNPN5tvjzqA)

[top](#Table-Of-Contents)

#### Error Handling in the Functional Way - Returning Smarter Wrapper Types eg the Either Monad

Before I get to error monads such as `Either` and `Validated`, I'll try to briefly explain what Monads are. Monads are notoriously difficult concept to grasp, but once you have, its pretty easy to hold onto and it is a very useful concept (opinion) that can be implemented in most programming language, not just in FP.  

> [!TIP]
Error monads aren't strictly necessary if use ADTs as return types or if your language has its own approach to 'errors-as-values,' however, monads add some extra smarts to facilitate happy-path functional composition. Please read on. 

##### What are Monads aka Higher-Kinded Types

A monad is a burrito 🌯 (or a bento-box 🍱 😊). If you've looked into functional programming, you'll understand this aphorism because monads are a notoriously difficult concept to explain: Like a burrito, a monad is a wrapper object (the tortilla) around a type (the filling). This sounds like ADTs right? yes, but monads also add additional 'mapper' methods that are used to apply passed-in computations on the monad's wrapped type in order to transform it into a new result type (or produce a wrapped error). I prefer the bento-box analogy, because there are more moving parts to a bento-box which better describes a monad (opinion). Having a basic understanding is a useful concept to grasp. 

A core tenant of the functional paradigm is to produce a more declarative and expressive 'happy path' of composed computations that isn't polluted with interleaved error handling logic. In a monadic call chain, you define ‘what to do’ by chaining functions that return monads to achieve an end result, not ‘how to do it’ as in more imperative approaches. The happy path self-documents, it screams what the business logic does. In more imperative approaches, you often see that each result is checked using a conditional before continuing with the next computation. Some devs like this approach, ok cool, but others argue that polluting the happy path leads to unreadable code, especially for large call chains.  

Here are some features of a monad: 
- A monad is concept with a standard API - you can implement monads in almost any language, its not just for pure functional languages. 
- A monad can be used as a return type for your functions and goes beyond errors-as-values by adding the ability to do type-safe functional composition.
- A monad is a parametrised 'wrapper' type that is typically implemented with generics.
- An 'Either' monad is a very common monad, its wrapped type is either a successful result OR some form of failure result that is returned from a passed-in computation, never both. For example: `Either<LeftErrorValue, RightSuccessValue>` (note that Rust is [opposite](opposite), where left is success and right is error). 
- The *simple choice between error and success is essential for enabling functional composition in a consistent way:* this is a core distinction between monads and ADTs - ADTs lack the simple monad API (required `map` and `flatMap` methods).   
- The computation is passed-in using a standard API that defines two mapper methods - `map` and `flatMap`. 
    - The passed-in function argument is often named `next` to indicate that it is the next bit of computation to apply.
    - The 'next' computation operates on the monad's existing wrapped type to create the next result. 
    - The 'next' computation can optionally generate custom side-effects e.g., calling out to another system or writing a file to disk for example.
    - The 'next' function can be a normal function that returns a plain type, it does not have to be 'monad aware.' Alternatively, it can also be a function that itself returns another monad.
- The monad API is designed to enable functional composition in a standard and consistent way from left to right, transforming each monad's wrapped success type along the way to achieve a final end result.
    - As already mentioned, to do this in a consistent way, a monad must have two 'bind' methods called `map` and `flatMap` that each accept a computation. The computation is typically a function-reference or a lambda meaning map and flatMap are 'higher-order' functions. The given computation 'maps over' the monad's wrapped type to transform and return a new success type wrapped in a new monad instance (or a new error type wrapped in a new monad).
    - If a mapper function returns an error type, subsequent calls in the chain will short-circuit the computation and will simply return the erroneous `Either`. Short-circuiting continues until the end of the call chain.
- Monads exist for several common patterns of computation - you've likely used monads in several libraries and have not even realised.

[top](#Table-Of-Contents)

##### Basic Monad implementation 

Here is a very basic sample implementation of `Either` in Kotlin, inspired by the Arrow2 library: 

```kotlin
// A basic implementation of Either 
sealed class Either<out A, out B> {
    data class Left<A>(val value: A) : Either<A, Nothing>()   // left for error
    data class Right<B>(val value: B) : Either<Nothing, B>()  // right for success

    fun <C> map(fn: (B) -> C): Either<A, C> = flatMap { Right(fn(it)) }

    fun <A, C> flatMap(fn: (B) -> Either<A, C>): Either<A, C> = when (this) {
        is Right -> fn(this.value)
        is Left -> this as Either<A, C>
    }
}
```

 - A monad wraps a type `<A>`. Typically this is not a primitive type (int, float etc), but a type that requires its own constructor, hence 'higher-kinded' type.
 - A monad has a standard set of 'mapper' methods, also known as 'bind' methods  ('map' and 'flatMap'), and 'unit' methods sometimes called 'of' or name after 'of' e.g. 'ofLeft()' and 'ofRight()':

     - 1) The 'unit' methods initialise a monad `F` by wrapping the given type `<A>` within the monadic context and has the form: 
        - `F<A>.of(A)`

     - 2) The 'flatMap' method accepts a computation, typically a function-reference or lambda, which transforms `<A>` to `<B>`. This given function argument is often named 'next'. This passed-in 'next' function itself wraps `<B>` in a new monad result `F<B>`. The return value is directly (i.e. 'flatly') returned by flatMap, so I think a more accurate name for flatMap is 'mapAndFlatReturn'. FlatMap has the following form, notice the 'next' function's return type is the same as map's return type:
        - `F<A>.flatMap(next: (A) -> F<B>): F<B>`

     - 3) The 'map' method accepts a function/lambda that transforms `<A>` to `<B>`. This passed-in 'next' function returns the plain type `<B>`, not a monad as in flatMap.  Therefore, before returning this value, map wraps this plain value within a newly created monad instance meaning the return type is consistent with flatMap, i.e. `F<B>` (I think a more accurate name for map is 'mapWrapAndReturn'). Map has the form: 
        - `F<A>.map(next: (A) -> <B>): F<B>`


It is important to remember that you can use monads as smart return types for your functions whenever you need to. In the example above, the processing functions are globally declared for the sake of simplicity. You could easily create custom business objects that declare their own monadic functions, rather than limiting yourself to global functions. This is a more hybrid approach that span both OPP and FP, and is especially useful for encapsulating more complex stateful business logic.

Regarding exceptions in functional composition: If your language uses ‘Checked Exceptions’ (e.g., old-style Java or when using other JVM languages that call out to underlying old-style Java libs), you can’t throw checked exceptions during functional composition as they force you to handle the error and break the call chain with try/catch or throws statements. In this scenario, wrap the exception in the monadic context and return a left error. Note that throwing _unchecked_ exceptions is OK in a functional call chain as they don’t force you to pollute the happy path with try/catch or throws, but you likely still want to wrap the error in a monad to return an error-as-value e.g., if that error is not a programming error or an exceptional circumstance.

[top](#Table-Of-Contents)
##### Example Type Safe Functional Composition by Short-Circuiting on Errors

In the following examples, we will use monads to simplify a functional call chain. The functions that we will compose include monad aware functions and basic functions that return plain types:

```Kotlin
    // Global helper functions, the first two return Either monads, the last returns a plain type 
    fun validateIngredients(ingredients: List<String>): Either<BakingServiceError, OkVal> { }
    fun cook(ingredients: List<String> , temperature: Int): Either<BakingServiceError, OkVal> { }
    fun pack(pie: String, isFragile : Boolean): Either<BakingServiceError, OkVal> { }
    fun deliver(pie: String): Boolean { } // note, plain return type is not 'monad aware'
```

We use an ADT to model our errors - BakingServiceError with sub-types:

```Kotlin
    sealed class BakingServiceError {
        object BadIngredients: BakingServiceError()
        object TemperatureTooLow: BakingServiceError()
        object PackingFailed: BakingServiceError()
        data class PoorRating(val minRequiredScore: Int = 3): BakingServiceError(){
          companion object
        }
    }

    data class OkVal(val message: String)
```

1) *Check as we go* - In the first example test, we check for success or failure for each step as we go. We don't need to use a consistent error type in this example:

```Kotlin
    @Test
    fun `demo interleaved result checking`(){
        val ingredients = listOf("sugar", "water", "flower")
        val pie : String = "baked cherry pie"

        val bakePrepped = validateIngredients(ingredients)
        when(bakePrepped) {
            is Left<BakingServiceError> -> fail("unexpected left error")
            is Right<OkVal> -> assert(bakePrepped.value.message == "Ingredients ok")
        }

        val cookResult = bakePrepped.flatMap {  cook(ingredients, temperature = 180) }
        when(cookResult) {
            is Left<BakingServiceError> -> fail("unexpected left error")
            is Right<OkVal> -> assert(cookResult.value.message == "Cooked ok")
        }

        val packResult = cookResult.flatMap {  pack(pie, isFragile = false) }
        when(packResult) {
            is Left<BakingServiceError> -> fail("unexpected left error")
            is Right<OkVal> -> assert(packResult.value.message == "Packed ok")
        }

        val deliverResult : Either<BakingServiceError, Boolean> = packResult.map { deliver(pie) }
        when(deliverResult) {
            is Left<BakingServiceError> -> fail("unexpected left error")
            is Right<Boolean> -> assert(deliverResult.value )
        }
    }
```


2) *Just the happy path* - The above test can be simplified into the following, the 'happy-path' becomes far more readable. 
- __We need to use a consistent error type (`BakingServiceError`) for this to compile__. However, as in this example, this type can of course be polymorphic such as a custom ADT or an abstract base class. In doing this, you can model multiple success and/or error types . In a different example, the wrapped Left instance could be anything that extends `Throwable`, for example.
- __We only need to test for our final expected result (or the existence of an error)__.  We can safely ignore the interleaving success results - they act as carriers to deliver the final result.  
- __If you need to extract the error sub-type to perform different error handling behaviour, you can drill down and extract the error sub-type as shown below.__  

```Kotlin
    @Test  
    fun `demo happy path and check last result`(){  
        val pie = "baked cherry pie"  
        val ingredients = listOf("sugar", "water", "flower", "cherries")  

        val bakePrepped = validateIngredients(ingredients)  
        val cookResult = bakePrepped.flatMap {  cook(ingredients, temperature = 180) }  
        val packResult = cookResult.flatMap {  pack(pie, isFragile = false) }  
        val deliverResult = packResult.map { deliver(pie) }  
    
        when (deliverResult) {
            is Right<Boolean> -> assert(deliverResult.value == true)  // expected final result
            is Either.Left<BakingServiceError> -> {
                when (result.value) {
                    BakingServiceError.BadIngredients -> fail("error handle here")
                    BakingServiceError.TemperatureTooLow -> fail("error handle here")
                    BakingServiceError.PackingFailed -> fail("error handle here")
                }
            }
        }

    }

// We only need to extract the final result - map/flatMap will short-circuit on an error which allows us to compose the 'happy path' as shown above. On error, extract the error sub-type to do error-specific handling. 
```

> [!TIP] 
> Monads enable handling specific errors after the happy path.

3) *Condensed happy path* - The above example can be shortened further:   

```Kotlin
    val deliverResult = validateIngredients(ingredients)
        .flatMap {  cook(ingredients, temperature = 180) }
        .flatMap {  pack(pie, isFragile = false) }
        .map { deliver(pie) }
    // Extract our final result, or pattern match the error, same as above
```

##### Can I Combine Monads and ADTs to Model Multiple Success or Error states 

Yes. Our parameterised Left error and Right success types can each wrap a polymorphic type such as an ADT used to model all possible error and success variations. To continue our example, we add a new `PoorRating` data object to our ADT to return the minimum required rating should the pie receive a poor rating:  

```Kotlin
sealed class BakingServiceError {  
    object BadIngredients: BakingServiceError()  
    object TemperatureTooLow: BakingServiceError()  
    object PackingFailed: BakingServiceError()  
    // If we encounter a PoorRating Error, optionally provide the minimum required score
    data class PoorRating(val minRequiredScore: Int = 3): BakingServiceError(){
        companion object
    }
}  
  
data class OkVal(val message: String)
```

A pattern I've seen before is to specify an abstract base class such as `Throwable` so that any exception type can be returned (not thrown) by a business function wrapped in a Left e.g. 

```Kotlin
fun someBusinessFunction(): Either<OkVal, Throwable> {
    try{
         ... processing logic detects an error or throwns an exception 
    } catch(ex: SomeException) {
      return Left(ex)
    }
}
```

##### Other Error Monads such as Validation and Ior 

Monads exist for several standard patterns of computation. For example, we've already seen the `Either` monad for describing a success or failure result (see above), but others exist: 

- Validation Monad: Unlike the Either monad, a Validated monad does not short-circuit on the first encountered error. Instead, the purpose is to capture all the possible errors encountered in the entire call chain. The error type is thus typically a non empty list. A validated monad can only be used if the computations are independent where input to the next computation does not depend on the successful output of the previous. A simple example is capturing all the errors on a form. In fancy functional speak, the Validator is an _applicative functor_. 

- Ior Monad: Provides both a successful result and additional list of context messages collected along the way. An example would be a successful code compilation that has several deprecation warnings. Overall the routine was successful, but you also want to collect the additional context.  

##### Inlining within a Computation Block to Avoid Nesting 

As described above, monads are designed to be chained together. Depending on the logic you want to compose, this can sometimes require nesting of `flatMap` and `map` calls to achieve the desired result. Let's assume the following functions :

```Kotlin
fun intToString(n: Int): Either<Error, String> { /*... note String success val...*/ } 
fun stringToThing(s: String): Either<Error, Thing> { /*... note Thing success val...*/ }
fun Thing.summarize(): String { /*...simple extension function returns plain String...*/ }
```
To get the desired result, our first attempt at functional composition produces the following example. Note that we mix `flatMap` and `map` as required depending on the return types of the composed functions. We use `map` when our computation (`summarize`) does not itself return a monad, and `flatMap` when the computation does return a monad. The resulting composition requires some nesting, urgh: 

```Kotlin
fun foo(n: Int): Either<Error, String> =
  intToString(n).flatMap { s -> stringToThing(s).map { t -> t.summarize()  } }
```
To address this, several languages have introduced sequential computation blocks that flatten the call chain.  For example, this includes [Scala's for comprehension](https://docs.scala-lang.org/tour/for-comprehensions.html), [Haskell's do notation](https://en.wikibooks.org/wiki/Haskell/do_notation) and [Kotlin's Arrow2 Raise DSL](https://arrow-kt.io/learn/typed-errors/from-either-to-raise/).  I use , an idiomatic Arrow2 example is shown below using the Raise DSL which includes the `either` block builder:

```Kotlin
fun foo(n: Int): Either<Error, String> = either {
  val s = intToString(n).bind() // use assignments in the call chain if needed 
  log(s) 
  val t = stringToThing(s).bind()
  t.summarize()
}
```
No nesting, much nicer, but where did those `bind()` methods come from, they aren't declared on Arrow2's `Either` type and what do they do?  Well, those bind functions are extension functions that can be grafted onto `Either` if used within the scope of the `either` block. Recall from our discussion on pervasive polymorphism above, that some languages (Kotlin, C#) use extension functions to allow you to extend existing types. 

- Q. So, how does this either block flatten the nested call chain? 
- A. Within the `either` block, instead of potentially having to nest function calls like you would with `map` and `flatMap`, you just use `bind()` on monadic functions which does two things: 1) it short-circuits the `either` block in the case of an error, and 2) it returns the wrapped/regular type, not a monad. Returning the wrapped/regular type from `bind()` enables flattening, it allows you to inline optional variable assignments e.g., to interleave some logging as in the example above . If an error does not occur, the `either` block then wraps the result of `t.summarize()` within the returned `Either` as a success.  For this to compile, the monadic functions need to share the same Error type - this is because the `either` block needs to return a known type `Either<Error, String>` in our example above.  Remember though, Either's success and error types types can be polymorphic as in the baking examples above. 

The Arrow2 implementation is an example of [extensions](https://kotlinlang.org/docs/extensions.html) with [extension receivers](https://kotlinlang.org/docs/extensions.html#declaring-extensions-as-members) and [function literals with receiver](https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver). It get quite complex with several variations, so please refer to the Kotlin and Arrow2 docs for more info and for tutorials. Hopefully however, this shows how errors are generally handled using monads in a functional call chain.  

[top](#Table-Of-Contents)

### Effect Orientated Programming

In the functional error handling examples above, we use the `Either` monad as a smarter return type to bring back our happy path by allowing us to compose a selection of global functions. It is important to remember that we can apply the monad API in custom business objects to encapsulate custom operations with controlled side-effects: 

>[!TIP]
Recognise that the monad API (mainly `map()` and `flatMap()`) can be used to build your own smart custom types that have controlled side-effects. We refer to this monadic custom business logic as a 'Higher Kinded' type. 

>[!TIP]
>"Monads allow you to write happy path code within the context of a monad. A monad wraps all the errors that could possibly go wrong, groups them all up, and lets you deal with that failure outside of the monad's business logic. It basically encapsulates all the side-effects and possible errors. The net result is more reliable and readable higher-level happy-path code."  Paraphrasing Kris Jenkins (who hosts the Developer Voices podcast) in this episode of [Happy Path Programming podcast](https://pod.link/1531666706/episode/710a605d605fda251f2e83b8858615b8) 

Kris goes on to explain that there is "a heck a lot of information communicated in a Haskell type/function signature - Haskell type signatures are so semantically dense, which is why some new users to Haskell think the documentation is so thin."  

I'm not going to use Haskell, I don't know enough, but I do recognise the elegance of a custom 'Higher Kinded' monad for modelling a domain in a reliable way. In the example below, I use a custom higher kinded business object called `Account`.  Note: 
- The smart constructor used to return the `Either` that wraps an `Account` or a `NegativeAmount` error on account creation. 
- The custom business functions `withdraw` and `deposit` that operate on an instance of `Account`. 
- An ADT wraps all known business errors - `AccountError`
- The `transferMoney` static method which can fail due to a flaky network. If the transfer fails, we catch the offending `IOException` and return a `AccountError.TransactionFailed(ex)` and wrap the original cause. 

```Kotlin
sealed class AccountError {
    object NegativeAmount : AccountError()
    object NotEnoughFunds : AccountError()
    object AccountNotFound : AccountError()
    data class TransactionFailed(val exception: Exception?) : AccountError()
}

@ConsistentCopyVisibility
data class Account private constructor(val balance: BigDecimal) {
    companion object { // functions within the companion are statics
        operator fun invoke(initialBalance: BigDecimal): Either<NegativeAmount, Account> =
            applyAmount(initialBalance) { Account(it) } // smart constructor

        fun create(initialBalance: BigDecimal): Either<NegativeAmount, Account> =
            applyAmount(initialBalance) { Account(it) }

        private fun applyAmount(amount: BigDecimal, fn: (BigDecimal) -> Account) =
            if (amount < ZERO) Left(NegativeAmount) else Right(fn(amount))

        /**
         * Convenience function to create a new Account or throw IllegalArgumentException.
         * Not recommended for production use, use Constructor instead.
         */
        fun createOrThrow(initialBalance: BigDecimal): Account {
            var accountResult = applyAmount(initialBalance) { Account(it) }
            return when(accountResult) {
                is Right<Account> -> accountResult.value
                is Left<*> -> throw IllegalArgumentException()
            }
        }

        /**
         * @return Updated debtor and creditor Accounts in a Pair instance, or an AccountError if the transfer fails, 
         * for whatever reason such as flaky network.
         */
        fun transferMoney(debtor: Account, creditor: Account, amount: BigDecimal): Either<AccountError, Pair<Account, Account>> {
            return try {
                // In the real-world, this might be a flaky network operation than can fail
                debtor
                    .withdraw(amount)
                    .flatMap { d -> creditor.deposit(amount).map { Pair(d, it) } }
            } catch(ex: IOException){
                Left(AccountError.TransactionFailed(ex))
            }
        }
    }

    fun copyAccount(balance: BigDecimal): Account = this.copy(balance = balance)

    fun deposit(amount: BigDecimal): Either<NegativeAmount, Account> =
        applyAmount(amount) { this.copyAccount(balance = this.balance + it) }

    fun withdraw(amount: BigDecimal): Either<AccountError, Account> =
        applyAmount(amount) { this.copyAccount(balance = this.balance - it) }
            .flatMap {
                if ((balance - amount) < ZERO) Left(NotEnoughFunds) else Right(Account(balance - amount))
            }
}
```

Here are some corresponding tests that show Account usage:

```Kotlin
    @Test  
    fun `should fail creating an account with a negative amount`() {  
        assert(Account.create((-100).toBigDecimal()) == Left(NegativeAmount))  
    }
    @Test
    fun `should withdraw money from an account`() {
        val account = Account.createOrThrow(100.toBigDecimal())
        val updatedAccount = account.withdraw(50.toBigDecimal())
        assert(updatedAccount == Right(buildAccountViaReflectionForTestsOnly(50.toBigDecimal())))
    }

    @Test
    fun `should fail withdrawing a negative amount to an account`() {
        val account = Account.createOrThrow(100.toBigDecimal())
        val fail = account.withdraw((-50).toBigDecimal())
        assert(fail == Left(NegativeAmount))
    }

    @Test
    fun `should fail withdrawing when there is not enough funds`() {
        val account = Account.createOrThrow(100.toBigDecimal())
        val fail = account.withdraw(200.toBigDecimal())
        assert(fail == Left(NotEnoughFunds))
    }

    @Test
    fun `should transfer money across two different accounts`() {
        val debtor = Account.createOrThrow(100.toBigDecimal())
        val creditor = Account.createOrThrow(100.toBigDecimal())
        val result = Account.transferMoney(debtor, creditor, 50.toBigDecimal())
        assert(result == Right(Pair(buildAccountViaReflectionForTestsOnly(50.toBigDecimal()), buildAccountViaReflectionForTestsOnly(150.toBigDecimal())) ))
    }
```
Bento-box is better analogy for describing higher kinded types.  
### Concurrency and Parallelism

In computing, concurrency is not parallelism, despite the two terms having very similar dictionary definitions. *Concurrency is a software concern* involving context switching of a process on a single CPU core via a ‘kernel thread’ (these types of thread are also commonly referred to as process thread, carrier thread, and platform thread) . Context switching gives the illusion that multiple things are happening at once because the time slicing is so small. *True parallelism is both a software and hardware concern* which requires increasingly more hardware to do more things at once. This can range from multiple cores on one CPU, multiple CPUs, multiple nodes, remote actors, remote VMs, cloud functions such as Lambda and more. 

For example, parallelism with increasingly heavyweight implementations from small to large could range from:
- Single host with shared memory parallelism using low level platform threads and locks (mutexes), where threads map to cores. Programming with platform threads and locks is low level and is really for library developers rather than application developers.
- Single host with shared memory parallelism using software abstractions built on lower level threads, such as co-routines with channels for sharing data, virtual threads a.k.a. fibers, async/await methods, pragmas to parallelise tight loops such as used in in OpenMP.   
- Multi-processing where each child-process has its own memory space and data is separately distributed to each process for processing, or data can be shared using inter-process-communication mechanisms (IPC) such as memory-mapped files (memory and disk) or messaging over sockets.
- K8s worker nodes/pods hosted in the same K8s cluster with communication over ethernet. 
- HPC using compute clusters where 'tightly coupled' workloads message-pass over a high performance interconnect (MPI). 
- Geographically distributed compute nodes/servers such as remote Actors / FaaS / Grid computing / service mesh. 
- Geographically distributed multi-clustering (e.g., Grid, federated HPC - a potential route to exa-scale). 

Some general recommendations:
- Keep platform threads as isolated as possible & limit mutable global state:
    - Sharing of fixed immutable state is fine.
    - Taking defensive copies of data can help prevent race conditions and other concurrency related ‘spooky actions at a distance’.
    - Try to be more functional and limit your use of global mutable state.
    - Understand the pitfalls of multi-threaded code such as race-conditions, ghost reads, dirty reads, dirty writes, and thread deadlock.

- Keep synchronised critical sections as small as possible:
     - Amdahl’s law: "The overall performance improvement gained by optimising (i.e. parallelising) a single p art of a system is limited by the fraction of time that the improved part is actually used," or more simply: even a small amount of synchronization *_significantly*_ affects performance.
     - Here are some examples of Amdahl's law:
         - If 95% of the time spent by your code is parallel, throwing more processors at the problem does not improve speed up beyond ~256 processors.
         - If the amount of time spent by your code is <50% parallel, adding more processors won't speed up your code at all.
         - If the amount of time spent by your code is ~95% parallel, the maximum speed up is only 20 times and this takes 2048 processors.

![](attachments/Pasted%20image%2020240611095042.png)

[top](#Table-Of-Contents)

- Understand the pitfalls of multi-threaded programming. If deadlock, live-lock, ghost-reads, dirty reads, and atomic vs composite actions don’t make much sense to you (do you think ‘i++’ is atomic? – no it is not), then you will no doubt run in to problems. For application developers rather than lower level library developers, there is often a much better approach to coding low-level multi-threaded and shared memory models.
-  When testing, use more threads than processors – running with more threads than processor cores encourages task swapping. The more frequently your tasks swap, the more likely you will find issues.

[top](#Table-Of-Contents)

#### Know the difference between IO bound tasks and CPU bound tasks and their solution patterns

*IO Bound Tasks* require asynchronous patterns to achieve concurrency. The solution patterns include:

- **Async/Await** (e.g., Rust/C# async/await functions and Kotlin’s suspending functions). These are often referred to as ‘coloured approaches’ because your functions are typically split into two types; 1) red functions for asynchronous code typically requiring special keyword modifiers to annotate functions and their call-sites e.g. `async` (function) and `await` (call-site) and; 2) blue functions for plain synchronous code having no modifiers. Here is the [original and now famous blog - What Color is Your Function](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function)
- **Colourless Coroutines** (e.g. Go's Goroutines). Go's Goroutines are not coloured because they only require the `go` keyword at the function call-site, there is no need to annotate a function as asynchronous which allows you to call regular functions in an asynchronous way (although you frequently need to pass in concurrency primitives to share data such as `Channels`). 
- **Virtual-Threads / Green Threads / Fibres** such as the ‘colourless’ [Project Loom](https://wiki.openjdk.org/display/loom/Main) for the JDK where the virtual threads are implemented in user space using continuations. With the release of Loom, the venerable JVM platform arguably boasts the most advanced approach to concurrency. JVM languages can implement a truly colourless programming approach on top using a combination of platform and virtual threads and higher-level abstractions such as the streams API. 
- **Continuations** are very low-level and are used to implement patterns such as coroutines & virtual threads. Continuations can be suspended, stored on the heap, and restarted. Typically, you would not directly use continuation APIs using a Continuation Passing Style (CPS) in your own application logic, although some languages do have public APIs for CPS.
- **Async-Wrapper types such as Futures & Promises.** Note that these are really just higher-level synchronisation primitives, and the task that you await itself would need to be non-blocking to achieve high levels of concurrency.  
- **Call-Back functions** (beware ‘call-back hell’ as often seen in JavaScript). In fact, more friendly ‘synchronous’ patterns such as Coroutines and Continuations simply abstract much of the lower-level call backs from the programmer.
- **Non-blocking IO primitives** where libs & APIs are non-blocking instead of blocking.
- **Reactive Frameworks** e.g., project Reactor. Performant, but typically requiring a horrible API that has a lot of 'hidden magic.' In the JDK space, with the delivery of Project Loom (see above), I believe reactive approaches will decrease in popularity.

[top](#Table-Of-Contents)

*CPU Bound Tasks* have different solution patterns:

- **Platform/OS/POSIX/Kernel threads (pthreads).** These are good for numerical computations that do not require much, preferably no, IO. An example would be a ‘tight computational loop’ that performs an in-memory calculation that has no side-effects.  Note that platform threads are rather heavyweight and so should be pooled for effective resource usage (see Fork-Join-Pools). For example, on Linux, each thread typically requires ~1MB of memory per thread – this is because they are controlled by the operating system, and the OS has to be generic enough to handle a variety of use-cases, so 1MB was assumed to be a catch-all default. Platform threads are _very_ different from Virtual Threads in terms of how they are implemented.  A platform thread is very similar to a process in terms of resource-cost, except that threads allows memory sharing between multiple threads while multiple processes do not share the same memory space. For multiple processes, you need some other mechanism to share state and messages between processes, such as a common memory-mapped file(s), file system, databases, and message brokers.
- **Shared memory frameworks** such as OpenMP which make multi-threaded programming simpler by avoiding low-level synchronisation primitives.  
- **Fork-Join-Pools and related ‘Work Stealing’** patterns that involve task queues. FJP is a highly recommended way to achieve best possible performance because low-level Kernel/OS threads are re-used to maximum effect.
- **Horizontal scaling with Pub-Sub and Competing Consumers.** This is where multiple compute nodes subscribe to a message channel and pull messages from the channel. If the queue-depth gets too high, you add more consumers to process the messages.
- **Lazy Parallel Streams** in functional approaches. Functional streams are typically executed lazily, importantly after the whole computation has been fully defined. This allows the caller or runtime to perform optimisations such as automatic parallelisation. This can only be achieved because the full stream is defined lazily, ahead of time.    
- **Message Passing** e.g., the Actor model (e.g., Akka) & Message Passing Interface (e.g., OpenMPI) in HPC are both examples of message passing. Note that the Actor model is actually the canonical parallelism pattern, while MPI is quite niche (largely just the HPC community).


If you must use low-level locks and synchronization primitives with critical sections, try to use ‘re-entrant’ locks for better composability and performance over non-re-entrant synchronized blocks. Check if the languages mutexes (semaphores, count-down latches) are re-entrant (language agnostic advice).

[top](#Table-Of-Contents)

### Security Development Practices

- For Hartree folks, if using a cloud hosted development environment, you must consult and agree to the practices given in [Hartree’s Cloud Acceptable Use Policy](https://stfc365.sharepoint.com/:w:/r/sites/HartreeIGaA/ISO27001/Information%20Security%20Management%20System/Policies/HCIS-0044-plc-01.1-Cloud%20Access.docx?d=wc3116a720ba941cc9de27c0029df1932&csf=1&web=1&e=zkvG1Q) document. All polices and related information can be found [here](https://stfc365.sharepoint.com/sites/HartreeIGaA/ISO27001/Forms/AllItems.aspx?csf=1&web=1&e=ZWjlia&siteid=%7B938CBF09%2D9359%2D4BB6%2DB56D%2D55D938C510C1%7D&webid=%7B02B09618%2D9B45%2D479E%2DBFA4%2D9DEE7B833CA6%7D&uniqueid=%7B8BE63CF1%2DD73D%2D441D%2D9570%2DCD95D488D38A%7D&RootFolder=%2Fsites%2FHartreeIGaA%2FISO27001%2FInformation%20Security%20Management%20System&FolderCTID=0x012000AFB03BC45914F7439215AF3907065BF0).

![](attachments/Pasted%20image%2020240611100053.png)

[top](#Table-Of-Contents)

- Never add plain-text credentials including username/passwords and ssh keys/tokens into version control.
- Sensitive data such as credentials can be stored locally in your local dev environment using ephemeral sources such as environment variables, command line arguments, local files such as '.env' files that are git ignored (use a '.gitignore' file) to ensure they are not committed to VCS, and local key-chains / credential stores such as HashiCorp's vault and [https://github.com/openbao/openbao](https://github.com/openbao/openbao) .
- Do not hard-code secrets in code. For production, use well-established secret serving methods such as creating a secret object in OpenShift that configures environment variables for your running pods.  
- Public URLs should always be secured using TLS/HTTPS. Host certificates can be freely obtained from [https://letsencrypt.org](https://letsencrypt.org)  
- Always consider linting and scanning your code for vulnerabilities and anti-patterns using well-established tooling such as FindBugs, Snyk for containers, OWASP's Dependency Check tool suite: [https://owasp.org/www-project-dependency-check](https://owasp.org/www-project-dependency-check)  
- Familiarise yourself with OWASP's Top Ten security risks for webapps: [https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten)  
- Always update default passwords that are shipped with products e.g., 'admin' is sometimes used default username and password pair.
- To minimize injection attack surface, don’t use your own variable binding or hard code parameters using string concatenation – use the supported variable binding tooling to ensure values are always escaped.

[top](#Table-Of-Contents)

## Agile Process Guide aka Feedback Driven Development

For the Hartree Centre, we propose an Agile methodology as it largely suits the type of projects we do. Agile is an overused term, so for Hartree’s purposes, a good definition is ‘Feedback Driven Development’.  Iteration and customer feedback really ARE essential if we are to successfully address real customer needs. Know that industry data shows that even for the best software companies in the world, two thirds of their ideas produce zero or negative value so continuous feedback is essential to mitigate the risks: Online Controlled Experiments at Large Scale: [http://ai.stanford.edu/~ronnyk/2013%20controlledExperimentsAtScale.pdf](http://ai.stanford.edu/~ronnyk/2013%20controlledExperimentsAtScale.pdf)

[top](#Table-Of-Contents)

According to the values of the original Agile manifesto (search the original ‘Snowbird meeting’), agile development practices include risk-taking, rapid-feedback, frequent and high-bandwidth communications across the whole team, and collective project ownership. This means full stakeholder involvement with everyone: developers, testers, scientists, end-users, and business-development managers. It emphasises ‘individuals and interactions over processes and tools.’ Agile is especially relevant for greenfield and relatively short-lived projects which describe many of the projects we do at the Centre.

[top](#Table-Of-Contents)

We recommend weekly or fortnightly iterations involving customer playbacks and demos. Anything longer than 2 weeks can require significant course correct if/when you go in the wrong direction - agile aims to catch problems early and to course correct.  According to Uncle Bob Martin, the emergence of agile was to “find out how screwed we were as early as possible, it was not just about writing software quickly”.

[top](#Table-Of-Contents)

### Design Thinking Workshops and Scoping Document

Design Thinking puts you in the shoes of the customer so that you can understand their pain points. This helps design solutions that really address customer needs. Hartree have a set of recipes for activities that you can use to conduct [DT workshops](https://stfc365.sharepoint.com/:f:/r/sites/TheHartreeCentreCommunityChannel/Shared%20Documents/Hartree%20Communications/Business%20Development/Design%20Thinking%20Workshops?csf=1&web=1&e=cpdeqS). The activities don’t have to be applied religiously and you can adapt as needed. The activities include As Is Scenario Journey Map, Empathy Maps, User Persona and Problem Statements, User Stories, Ideation, Prioritisation, Ideal To-Be Scenario Journey Map, Outcome Statements, Cupcake road maps.

Hartree also has a [scoping doc](https://stfc365.sharepoint.com/:f:/r/sites/TheHartreeCentreCommunityChannel/Shared%20Documents/Hartree%20Communications/Business%20Development/Design%20Thinking%20Workshops?csf=1&web=1&e=cpdeqS) that you can send the customer ahead of time to help focus minds.

[top](#Table-Of-Contents)

### Epics and Work Package Span Multiple Sprints

Epics are like Work Packages. Typically, they require multiple tasks and span multiple sprints.

### Define user stories with the INVEST Framework or Who-What-Why or the Connextra Card Template – all are good and you do not need to be too rigid

- _“As userType [X], I need a way to do [what?] so that I can [what’s the benefit]”._

- _Who, What Why_

- INVEST:
 	- Independent - this means we try to design stories that do not need to be implemented in a particular order (a soft rule as there may well be stories that need to be prioritised).
 	- Negotiable - to retain agility, we recognise that requirements often/inevitably evolve and so we don't focus overtly on getting the details right up-front (i.e., Waterfall).
 	- Valuable - must have a clear and quantifiable benefit to the client.
 	- Estimable - a story must be concrete enough that developers can estimate it.
 	- Small - a story must not be larger than one or two developers can implement in a single iteration.
 	- Testable - when a developer says that its 90% ready, nobody really knows how close it is to being finished.
  
[top](#Table-Of-Contents)

### Arrange core user stories into a Journey Map with a narrative flow or backbone of Big Activities moving from left to right

Beneath each big activity, define short verb phrases to describe what the user does to achieve each big activity.

![](attachments/Pasted%20image%2020240611100610.png)

[top](#Table-Of-Contents)

### Task Backlog

Create a list of tasks and use ‘planning poker’ / finger-waving to estimate effort – after a ‘3, 2, 1’ countdown, everyone at the same time provides an estimate of the difficulty of a task between 1 and 5 or holds up a card. This ensures honest estimates from everybody which is Important because different team members may have different experiences/specialities of the task area. See [https://www.evernote.com/l/AWQ6FGRtfrNI1az21FVp9aosQ9zu8b-4CXg](https://www.evernote.com/l/AWQ6FGRtfrNI1az21FVp9aosQ9zu8b-4CXg)

### Requirements Document and System Architecture Document

### 1 to 2-week Sprints  

Break up the Backlog into sprints to deliver your cup-cake roadmap. Provide effort estimations for tasks using ‘planning poker’. More than two weeks generally gives enough time for software to deviate without requiring significant refactoring and course-correction, so we don’t recommend more than 2 weeks.

[top](#Table-Of-Contents)

### Inline Testing

Test the critical path and be pragmatic about coverage - 80% coverage often not feasible or even useful. Develop tests in-line with the mainline branch. TDD helps us think about the public interfaces / API to the code under development.

### Demo and Playbacks

At the end of the sprint, demo your progress to the client. This is important. Agile can be paraphrased as ‘Feedback Driven Development’.  It is essential to get that customer feedback early and continuously.

[top](#Table-Of-Contents)

### Acceptance with Sign Off and Cucumbers

- If possible, get the client to sign-off work every month (PMO have a ‘Decision Point Review’ template).
- Use the Cucumber approach for acceptance testing i.e., ‘Given, When, Then’.  For example: ‘Given [a particular context/scenario], When [something happens], Then [this is the result]’.

### Iteration and Incrementalism

- Recognise that we need both iterative & incremental approaches to building complex systems. Incrementalism == modularity, which helps break down complexity.
- Review the Backlog, revise and plan your next sprint, jump to 7.

![](attachments/Pasted%20image%2020240611100815.png)

[top](#Table-Of-Contents)

### Cup Cake Road Maps

- Plan a cup-cake dev roadmap. A cup-cake won’t feed everyone, but it can have core ingredients - it’s a whole-product that a user can taste sooner rather than later.
- If the cup-cake tastes good, proceed with the vanilla sponge, hopefully ending with the multi-tier wedding cake that can feed everyone. Iterate your development roadmap and keep soliciting user feedback.

Thanks for reading, comments/feedback most welcome. Have fun !

[top](#Table-Of-Contents)

## Appendix Recommended Texts

![](attachments/Pasted%20image%2020240611100930.png)

![](attachments/Pasted%20image%2020240611100944.png)

[top](#Table-Of-Contents)

---
